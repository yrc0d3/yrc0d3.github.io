[{"categories":["mac"],"content":"为了学习linux内核，安装一个ubuntu虚拟机比较方便。 ","date":"2022-03-26","objectID":"/apple_silicon_mac_install_vm_ubuntu/:0:0","tags":["mac"],"title":"Apple Silicon M1的Mac电脑安装ubuntu虚拟机","uri":"/apple_silicon_mac_install_vm_ubuntu/"},{"categories":["mac"],"content":"安装虚拟机软件 Parallel Desktop收费，pass。 VMWare Fusion还是技术预览版。 最终选择了UTM。 ","date":"2022-03-26","objectID":"/apple_silicon_mac_install_vm_ubuntu/:1:0","tags":["mac"],"title":"Apple Silicon M1的Mac电脑安装ubuntu虚拟机","uri":"/apple_silicon_mac_install_vm_ubuntu/"},{"categories":["mac"],"content":"下载安装ubuntu https://mac.getutm.app/gallery/ubuntu-20-04 按照上面的指引安装即可。 ","date":"2022-03-26","objectID":"/apple_silicon_mac_install_vm_ubuntu/:2:0","tags":["mac"],"title":"Apple Silicon M1的Mac电脑安装ubuntu虚拟机","uri":"/apple_silicon_mac_install_vm_ubuntu/"},{"categories":["mac"],"content":"修改分辨率 目前在用的MacBook Pro 14的分辨率为3024x1964，该分辨率还包含了刘海那一横条部分。ubuntu系统使用16:10的分辨率就好，刘海那一条置黑，因此需要的分辨率为3024x1890。 首次设置： cvt 3024 1890 sudo xrandr --newmode \"3024x1890_60.00\" 488.50 3024 3264 3592 4160 1890 1893 1899 1958 -hsync +vsync sudo xrandr --addmode Virtual-1 \"3024x1890_60.00\" sudo xrandr --output Virtual-1 --mode \"3024x1890_60.00\" 为了避免重启失效，把以下代码加入~/.profile中： cvt 3024 1890 xrandr --newmode \"3024x1890_60.00\" 488.50 3024 3264 3592 4160 1890 1893 1899 1958 -hsync +vsync xrandr --addmode Virtual-1 \"3024x1890_60.00\" xrandr --output Virtual-1 --mode \"3024x1890_60.00\" ","date":"2022-03-26","objectID":"/apple_silicon_mac_install_vm_ubuntu/:3:0","tags":["mac"],"title":"Apple Silicon M1的Mac电脑安装ubuntu虚拟机","uri":"/apple_silicon_mac_install_vm_ubuntu/"},{"categories":["读书笔记"],"content":"9.1 物理和虚拟寻址 图9-1展示了一个物理寻址（physical addressing）的示例。 图9-2展示了现代处理器使用的一种称为虚拟寻址（virtual addressing）的寻址方式。 MMU：Memory Management Unit，内存管理单元 ","date":"2021-01-04","objectID":"/csapp_chapter9/:1:0","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.2 地址空间 一个地址空间的大小是由表示最大地址所需要的位数来描述的。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:2:0","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.3 虚拟内存作为缓存的工具 概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。 在任意时刻，虚拟页面的集合都分为三个不相交的子集： 未分配的：VM系统还未分配（或者未创建）的页。 缓存的：当前已缓存在物理内存中的已分配页。 未缓存的：未缓存在物理内存中的已分配页。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:3:0","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.3.1 DRAM缓存的组织结构 我们用SRAM缓存表示位于CPU和主存之间的L1、L2和L3高速缓存，用DRAM缓存表示虚拟内存系统的缓存，它在主存中缓存虚拟页。 DRAM比SRAM速度慢大约10倍，而磁盘比DRAM慢大约10000倍，因此DRAM缓存不命中比SRAM缓存不命中要昂贵的多。归根到底，DRAM缓存的组织结构完全是由巨大的不命中开销驱动的。 因为大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常是4KB~2MB。由于大的不命中处罚，DRAM缓存是全相联的(fully associative)，即任何虚拟页都可以放置在任何的物理页中。不命中时的替换策略页很重要，因为替换错了虚拟页的处罚页非常之高。因此，与硬件对SRAM缓存相比，操作系统对DRAM缓存使用了更复杂精密的替换算法。最后，因为对磁盘的访问时间很长，DRAM缓存总是使用写回（write-back），而不是直写（write-through）。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:3:1","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.3.2 页表 页表(Page Table)将虚拟页映射到物理页，它是一个页表条目(Page Table Entry, PTE)的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。 假设每个PET是由一个有效位和一个n位地址字段组陈的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:3:2","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.3.3 页命中 ","date":"2021-01-04","objectID":"/csapp_chapter9/:3:3","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.3.4 缺页 图9-6展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字（VP3并未缓存在DRAM中）。地址翻译硬件从内存读取PTE3，从有效位推断VP3未被缓存，然后触发了一个缺页异常。缺页异常调用内核中的缺页异常处理程序，选择一个牺牲页，即存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。 图9-7展示了在缺页之后我们的示例页表的状态。 在磁盘和内存之间传送页的活动叫做交换(swapping)或者页面调度(paging)。页从磁盘换入(或页面调入)DRAM，从DRAM换出(或页面调出)磁盘。现代操作系统使用的页面调度策略叫做按需页面调度(demand paging)，这种策略一直等待直到最后时刻（也就是当由不命中发生时）才换入页面。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:3:4","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.3.5 分配页面 VP5的分配过程时在磁盘上创建空间并更新PTE5，使它指向磁盘上这个新创建的页面。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:3:5","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.3.6 又是局部性救了我们 虚拟内存效率很高，主要归功于局部性(locality)。 尽管程序在整个运行过程中引用的不同页面的总数可能超过物理内存总大小，但是局部性原则保证了任意时刻，程序将趋向于在一个较小的活动页面(active page)集合上工作，这个集合叫做工作集(working set)或者常驻集合(redident set)。 只要程序由好的时间局部性，虚拟内存系统就能工作得相当好。如果工作集的大小超出了物理内存的大小，那么程序将产生一种不幸的状态，叫做抖动(thrashing)，这时页面将不断地换进换出。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:3:6","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.4 虚拟内存作为内存管理的工具 实际上，操作系统为每个进程提供了一个独立的页表，也就是一个独立的虚拟地址空间，如图9-9。注意，多个虚拟页面可以映射到同一个共享物理页面上。 按需页面调度和独立的虚拟地址空间的结合，对系统中内存的使用和管理造成了深远的影响。 简化链接。独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。这样的一致性极大地简化了链接器的设计和实现。 简化加载。要把目标文件中.text和.data加载到一个新创建的进程中，linux加载器为代码段和数据段分配虚拟页，把他们标记为无效的，被引用时按需加载即可。 简化共享。在一些情况下，需要进程间共享代码和数据，比如printf。操作系统将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这个部分代码的一个副本。 简化内存分配。当进程申请堆空间时，操作系统分配k个连续的虚拟内存页面，并把它们映射到物理内存中任意位置的k个物理页面。由于页表的工作方式，无需分配k个连续的物理内存页面，可以随机分散在物理内存中。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:4:0","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.5 虚拟内存作为内存保护的工具 地址翻译机制可以以一种自然的方式来提供内存访问控制。每次CPU生成一个地址时，地址翻译硬件都会读一个PTE，所以通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简答。 图9-10展示的示例中，每个PTE中添加了三个许可位。SUP表示进程是否必须运行在内核模式下才能访问该页。READ和WRITE位控制对页面的读写访问。 如果一条指令违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell一般将这种异常报告为\"段错误(segmentation fault)\"。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:5:0","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.6 地址翻译 本节讲述的时地址翻译的基础知识，但省略了大量的细节，尤其是和时序相关的细节。图9-11概括了我们在这节里要使用的所有符号。 形式上来说，地址翻译时一个N元素的虚拟地址空间中元素和一个M元素的物理地址空间中元素之间的映射。图9-12展示了MMU如何利用页表来实现这种应映射。CPU中的一个控制寄存器，页表基址寄存器(Page Table Base Register, PTBR)指向当前页表。 图9-13a展示了当页面命中时，CPU硬件执行的步骤： 第1步：处理器生成一个虚拟地址，并把它传送给MMU。 第2步：MMU生成PTE地址，并从cache/main memory请求得到它。 第3步：cache/main memory向MMU返回PTE。 第4步：MMU构造物理地址，并把它传送给cache/main memory。 第5步：cache/main memory返回所请求的数据给处理器。 页面命中完全是由硬件来处理的。与之不同的是，处理缺页要求硬件和操作系统内核协作完成，如图9-13b所示： 第1步到第3步：同9-13a中的第1步到第3步。 第4步：PTE中的有效位是0，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。 第5步：缺页处理程序确定处物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。 第6步：缺页处理程序将调入新的页面，并更新内存中的PTE。 第7步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，开始执行图9-13a中的步骤。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:6:0","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.6.1 结合高速缓存和虚拟内存 大多数操作系统，使用物理地址来访问SRAM高速缓存。使用物理寻址，多个进程同时在高速缓存中由存储块和共享来自相同虚拟页面的块称为很简单的事情，而且高速缓存无需处理保护问题（地址翻译来处理）。 图9-14展示了一个物理寻址的高速缓存是如何和虚拟内存结合起来的。主要思路是地址翻译发生在高速缓存查找之前。注意，页表条目也可以缓存。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:6:1","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.6.2 利用TLB加速地址翻译 MMU查阅PTE不命中时，会从内存多取一次数据，代价时几十到几百个周期。如果PTE碰巧缓存在L1 cache中，那么开销下降到1到2个周期。许多系统试图消除这些开销，它们在MMU中包括了一个关于PTE的小型缓存，称为翻译后备缓冲器(Translation Lookaside Buffer, TLB)。 TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相连度。 图9-16a展示了当TLB命中时的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。 第1步：CPU产生一个虚拟地址。 第2步和第3步：MMU从TLB中取出相应的PTE。 第4步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到cache/main memory。 第5步：cache/main memory将所请求的数据字返回给CPU。 图9-16b展示了当TLB不命中时的步骤。MMU必须冲L1缓存中取出相应的PTE。新取出的PTE存在到TLB中，可能会覆盖一个已经存在的条目。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:6:2","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.6.3 多级页表 假设我们有一个32位虚拟地址空间，页面大小4KB，PTE为4B。如果使用一级页表的话，需要4MB($4K=2^{12}, 32-12=20, 2^{20} * 4B=4MB$)的页表驻留在内存中。 用来压缩页表的常用方法是使用层次结构的页表。图9-17展示了为这个虚拟地址空间构造一个两级的页表层次结构。 一级页表中每个PTE负责映射一个4MB的片(Chunk)，每一片都由1024个连续的页面组成。二级页表中的每个PTE负责映射一个4KB的虚拟内存页面。使用4B的PTE，一级和二级页表都是4KB，刚好和一个页面的大小是一样的。 这种方法从两个方面减少了内存要求。第一，如果一级页表中的一个PTE是空的，那么相应的二级页表根本不会存在。第二，只有一级页表需要总是在主存中；虚拟内存系统可以在需要时创建、调入或调出二级页表，这就减少了主存压力；只有最经常使用的二级页表才需要缓存在主存中。 图9-18描述了使用k级页表层次机构的地址翻译。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:6:3","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.6.4 综合：端到端的地址翻译 略。看后面i7的案例更好。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:6:4","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.7 案例研究：Intel Core i7/Linux内存系统 现在的Core i7实现支持48位(256TB)虚拟地址空间和52位(4PB)物理地址空间。还有一个兼容模式，支持32位(4GB)虚拟和物理地址空间。 图9-21给出了Core i7内存系统的重要部分。Linux使用的是4KB的页。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:7:0","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.7.1 Core i7地址翻译 图9-22总结了完整的Core i7地址翻译过程。 Core i7采用四级页表。CR3控制寄存器指向第一级页表(L1)的起始位置。CR3的值是每个进程上下文的一部分，每次上下文切换时，CR3的值都会被恢复。 图9-23给出了第一级、第二级或第三级页表中条目的格式。当P=1时(Linux中就总是如此)，地址字段包含一个40位物理页号(PPN)，它指向适当的页表的开始处。 图9-24给出了第四级页表中条目的格式。当P=1时，地址字段包含一个40位物理页号(PPN)，它指向物理内存中某一页的基地址。 PTE由三个权限位，控制对页的访问：R/W位，U/S位，XD位（禁止从某些内存页获取指令，比如限制只能执行只读代码段来降低内核遭受缓冲区溢出攻击的风险）。 当MMU翻译每一个虚拟地址时，它还会更新另外两个内核缺页处理程序会用到的位：A位，D位。 图9-25给出了Core i7 MMU如何使用四级页表来将虚拟地址翻译成物理地址。36位VPN被划为成四个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含到L1页表的物理地址。VPN1提供到L1 PTE的偏移量，这个PTE包含L2页表的基地址。VPN2提供到L2 PTE的偏移量，以此类推。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:7:1","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.7.2 Linux虚拟内存系统 Linux为每个进程维护了一个单独的虚拟地址空间，形式如图9-26所示。 内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理页面。 内核虚拟内存的其他区域包含每个进程都不相同的数据。比如，页表、内核在进程的上下文中执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。 1. Linux虚拟内存区域 Linux将虚拟内存组织成一些区域(area，也叫段segment)的集合。一个区域就是已经存在的(已分配的)虚拟内存的连续片(chunk)，这些页是以某种方式相关联的。每个存在的虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在的，并且不能被进程引用。区域的概念很重要，因为它允许虚拟地址空间有空隙。 图7-27强调了记录一个进程中虚拟内存区域的内核数据结构。task_struct中的元素包含或者指向内核运行该进程所需要的所有信息（PID、指向用户栈的指针、可执行目标文件的名字、程序计数器等）。 mm_struct描述了虚拟内存的当前状态。其中，pgd指向第一级页表的基址，而mmap指向一个vm_area_struct链表，其中每个vm_area_struct都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时，就将pgd存放在CR3寄存器中。 2. Linux缺页异常处理 假设MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序。它执行以下步骤： 虚拟地址A是合法的吗？如果不合法（不在任何区域中），则触发一个段错误，从而终止这个进程，对应图9-28中的情况1。 试图进行的内存访问是否合法？即检查权限。如果不合法，则触发一个保护异常，对应图9-28中的情况2。 选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送A到MMU。这次MMU就能正常地翻译A，而不会再产生缺页中断了。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:7:2","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.8 内存映射 Linux通过将一个虚拟内存区域与一个磁盘上的对象(Object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。虚拟内存区域可以映射到两种类型的对象中的一种： Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分。因为按需进行页面调度，所以这些虚拟页面没有实际交换进入物理内存，直到CPU第一次引用到页面。 匿名文件：内核创建，包含的全是二进制零。 无论哪种情况，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件(swap file)之间换来换去。交换文件也叫做交换空间(swap space)或者交换区域(swap area)。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:8:0","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.8.1 再看共享对象 一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。 假设进程1将一个共享对象映射到它的虚拟内存的一个区域，如图9-29a所示。现在进程2将同一个共享对象映射到它的地址空间。物理内存中只需要存放共享对象的一个副本。 私有对象使用一种叫做写时复制(copy-on-write)的技术被映射到虚拟内存中。一个私有对象开始生命周期的方式基本上和共享对象一样，在物理内存中只保存一份副本。如图9-30，对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制。只要没有进程试图写它的私有区域，它们就可以继续共享物理内存中对象的一个单独副本。然而，只要有一个进程试图写私有区域内的某个页面，就会触发一个保护故障，会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个恶心的副本，然后恢复这个页面的可写权限。 通过延迟私有对象中的副本直到最后可能的时刻，写时复制最充分地使用了稀有的物理内存。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:8:1","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.8.2再看fork函数 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:8:2","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.8.3 再看execve函数 假设运行在当前进程中的程序执行了如下的execve调用： execve(\"a.out\", NULL, NULL); 加载并运行a.out需要以下几个步骤： 删除已存在的用户区域 映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。图9-31概括了私有区域的不同映射。 映射共享区域。 设置程序计数器(PC)。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:8:3","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.8.4 使用mmap函数的用户级内存映射 Linux进程可以使用mmap函数来创建新的虚拟内存区域，并将对象映射到这些区域中。 #include \u003cunistd.h\u003e #include \u003csys/mman.h\u003e void mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset); int munmap(void *start, size_t length); 图9-32描述了参数的意义。 参数prot包含描述新映射的虚拟内存区域的访问权限位。参数flags由描述被映射对象类型的位组成。 munmap函数删除虚拟内存的区域。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:8:4","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9 动态内存分配 动态内存分配器(danymic memory allocator)维护着一个进程的虚拟内存区域，称为堆(heap)。堆紧邻bss段，向上生长(向更高的地址)。对于每个进程，内核维护着一个变量brk(break)，指向堆的顶部。 分配器将堆视为一组不同大小的块(block)的集合来维护。每个块就是一个连续的虚拟内存片(chunk)，要么是已分配的，要么是空闲的。 分配器有两种基本风格，都要求应用显式地分配块。它们的不同在于由哪个实体来负责释放已分配的块： 显式分配器(explicit allocator)：要求应用显式地释放任何已分配地块。例如c语言的malloc，用free来释放。 隐式分配器(implicit allocator)：要求分配器检测一个已分配块何时不再被程序使用，那么就释放这个块。隐式分配器也叫垃圾收集器(garbage collector)，自动释放未使用的已分配的块的过程叫做垃圾收集(garbage collection)。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:0","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.1 malloc和free函数 #include \u003cstdlib.h\u003e void *malloc(size_t size); // 若成功则返回已分配块的指针，若出错则为NULL void free(void *ptr); malloc函数返回一个指针，指向大小为至少size字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型做对齐。 malloc不会初始化它返回的内存。calloc函数会将分配的内存初始化为0。 free函数的ptr参数必须指向一个从malloc、calloc、realloc获得的已分配块的起始位置。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:1","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.2 为什么要使用动态内存分配 程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小。比如经常遇到数组直到使用时才能确定其大小。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:2","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.3 分配器的要求和目标 要求： 处理任意请求序列。 立即响应请求。 只使用堆。 对齐块。 不修改已分配的块。 目标：这两个目标通常时相互冲突的。 最大化吞吐量。 最大化内存利用率。 在我们的经验中，描述一个分配器使用堆的效率的最有用的标准，是峰值利用率(peak utilization)。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:3","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.4 碎片 内部碎片是在一个已分配块比有效载荷大时发生的。比如，一个分配器的实现可能对已分配块强加一个最小的size值，而这个size值比某个请求的有效载荷大。 外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大到可以处理这个请求时发生的。 外部碎片比内部碎片的量化要困难的多。因为外部碎片难以量化且不可预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:4","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.5 实现问题 一个分配器要在吞吐量和利用率之江把握好平衡，就必须考虑以下几个问题： 空闲块组织：我们如何记录空闲块？ 放置：我们如何选择一个合适的空闲块来放置一个新分配的块？ 分割：在将一个新分配的块放置到某个空闲块之后，我们如何处理这个空闲块中的剩余部分？ 合并：我们如何处理一个刚刚被释放的块？ ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:5","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.6 隐式空闲链表 任何实际的分配器都需要一些数据结构，允许它来区别块边界，以及区别已分配块和空闲块。大多数分配器将这些信息嵌入块本身。一个简答的方法如图9-35所示。 需要填充的原因由很多。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。 我们可以将堆组织成一个连续的已分配块和空闲块的序列。如图9-36所示。 我们称这种结构为隐式空闲链表，是因为空闲块是通过头部中的size字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的空间。 隐式空闲链表的优点是简单。显著的缺点是任何操作的开销，例如放置分配的块，要求对空闲链表进行搜索，该搜索所需时间与堆中已分配块和空闲块的总数呈线性关系。 还有很重要的一点就是系统对齐要求和分配器对块格式的选择会对分配器上的最小块的size由强制的要求。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:6","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.7 放置已分配的块 放置策略： 首次适配(first fit)：从头开始遍历空闲链表，选择第一个合适的空闲块。 下一次适配(next fit)：从上一次查询结束的地方开始搜索。 最佳适配(best fit)：检查每个空闲块，选择所需请求大小的最小空闲块。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:7","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.8 分割空闲块 一旦分配器找到一个匹配的空闲块，它就必须决定分配这个空闲块中的多少空间。最简单的选择就是使用这个空闲块，缺点是会造成内部碎片。另一种选择就是分割空闲块。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:8","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.9 获取额外的堆内存 如果分配器不能为请求找到合适的空闲块，那么它将通过合并那些在内存中物理上相邻的空闲块来创建一个更大的空闲块。如果还不够大，或者都合并完还不够，那么分配器会通过调用sbrk函数，向内核请求额外的堆内存。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:9","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.10 合并空闲块 为了解决假碎片问题，任何实际的分配器都必须合并相邻的空闲块，这个过程称为合并(coalescing)。 何时合并？立即合并(immediate coalescing)，或者推迟合并(deferred coalescing)。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:10","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.11 带边界标记的合并 分配器是如何实现合并的？对隐式空闲链表来说，合并下一个空闲块很简答。 那么如何合并前面的块呢？Knuth提出了边界标记(boundary tag)技术，允许在常数时间内进行对前面块的合并。它的思想是在每个块的结尾处添加一个脚部(footer)，这个脚部就是头部的一个副本。分配器可以通过脚部来判断前面一个块的起始位置和状态。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:11","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.12 综合：实现一个简单的分配器 略 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:12","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.13 显式空闲链表 堆可以组织成一个双向空闲链表，每个空闲块都包含一个pred和succ指针，如图9-48所示。 分配块和释放块的时间，取决于空闲链表中块的排序策略。一种方法是FIFO的顺序维护链表。另一种方法是按照地址顺序来维护链表，其中每个块的地址都小于它后继的地址。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:13","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.9.14 分离的空闲链表 分离存储(segregated storage)，就是维护多个空闲链表，其中每个链表中的块有大致相等的大小。一般的思路是将所有可能的块大小分成一些等价类，也叫做大小类(size class)。最简单的方式就是根据2的幂来划分块大小。 分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列。当分配器需要一个大小为n的块时，它就搜索相应的空闲链表。如果不能找到合适的块与之匹配，它就搜索下一个链表，以此类推。 有关动态内存分配的文献，描述了几十种分离存储方法，主要区别在于它们如何定义大小类，何时进行合并，何时向操作系统请求额外的堆内存，是否允许分割，等等。 1. 简单分离存储 每个大小类的空闲链表包含大小相同的块，每个块的大小就是这个大小类中最大元素的大小。 优点很多。分配和释放都是很快的常数时间的操作。每个片中都是大小相等的块，不分割，不合并，内存开销少。 一个显著的缺点是很容易造成内部和外部碎片。 2. 分离适配 分配器维护一个空闲链表的数组，每个空闲链表是和一个大小类相关联的，而且被组织成某种类型的显式或隐式链表。每个链表包含潜在的大小不同的块，这些块的大小是大小类的成员。 这里，我们描述了一种简单的版本。为了分配一个块，必须确定请求的大小类，并且对适当的空闲链表做首次适配，査找一个合适的块。如果找到了一个，那么就（可选地）分割它，并将剩余的部分插入到适当的空闲链表中。如果找不到合适的块，那么就搜索下一个更大的大小类的空闲链表。如此重复，直到找到一个合适的块。如果空闲链表中没有合适的块，那么就向操作系统请求额外的堆内存，从这个新的堆内存中分配出一个块，将剩余部分放置在适当的大小类中。要释放一个块，我们执行合并，并将结果放置到相应的空闲链表中。 分离适配方法是一种常见的选择，C标准库提供的GNU malloc包就是采用这种方法，既快速又高效。 3. 伙伴系统 伙伴系统(buddy system)是分离适配的一种特例，其中每个大小类都是2的幂。基本思路是假设一个堆的大小为$2^m$个字，我们为每个块大小$2^k$维护一个分离空闲链表，其中$0\\leqslant k \\leqslant m$。请求块大小向上舍入到最接近的2的幂。最开始时，只有一个大小为$2^m$个字的空闲块。 为了分配一个大小为$2^k$的块，我们找到第一个可用的、大小为$2^j$的块，其中$k\\leqslant j \\leqslant m$。如果 $j=k$，那么我们就完成了。否则，我们递归地二分割这个块，直到当我们进行这样的分割时，每个剩下的半块（也叫做伙伴）被放置在相应的空闲链表中。要释放一个大小为$2^k$的块，我们继续合并空闲的伙伴。当遇到一个已分配的伙伴时，我们就停止合并。 伙伴系统分配器的主要优点是它的快速搜索和快速合并。主要缺点是要求块大小为 2 的幂可能导致显著的内部碎片。因此，伙伴系统分配器不适合通用目的的工作负载。然而，对于某些特定应用的工作负载，其中块大小预先知道是 2 的幂，伙伴系统分配器就很有吸引力了。 ","date":"2021-01-04","objectID":"/csapp_chapter9/:9:14","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.10 垃圾收集 ","date":"2021-01-04","objectID":"/csapp_chapter9/:10:0","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.10.1 垃圾收集器的基本知识 ","date":"2021-01-04","objectID":"/csapp_chapter9/:10:1","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.10.2 Mark\u0026Sweep垃圾收集器 ","date":"2021-01-04","objectID":"/csapp_chapter9/:10:2","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.10.3 C程序的保守Mark\u0026Sweep ","date":"2021-01-04","objectID":"/csapp_chapter9/:10:3","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.11 C程序中常见的与内存有关的错误 ","date":"2021-01-04","objectID":"/csapp_chapter9/:11:0","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.11.1 间接引用坏指针 ","date":"2021-01-04","objectID":"/csapp_chapter9/:11:1","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.11.2 读未初始化的内存 ","date":"2021-01-04","objectID":"/csapp_chapter9/:11:2","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.11.3 允许栈缓冲区溢出 ","date":"2021-01-04","objectID":"/csapp_chapter9/:11:3","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.11.4 假设指针和它们指向的对象使相同大小的 ","date":"2021-01-04","objectID":"/csapp_chapter9/:11:4","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.11.5 造成错位错误 ","date":"2021-01-04","objectID":"/csapp_chapter9/:11:5","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.11.6 引用指针，而不是它所指向的对象 ","date":"2021-01-04","objectID":"/csapp_chapter9/:11:6","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.11.7 误解指针运算 ","date":"2021-01-04","objectID":"/csapp_chapter9/:11:7","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.11.8 引用不存在的变量 ","date":"2021-01-04","objectID":"/csapp_chapter9/:11:8","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.11.9 引用空闲堆块中的数据 ","date":"2021-01-04","objectID":"/csapp_chapter9/:11:9","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.11.10 引起内存泄漏 ","date":"2021-01-04","objectID":"/csapp_chapter9/:11:10","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"9.12 小结 ","date":"2021-01-04","objectID":"/csapp_chapter9/:12:0","tags":["caspp"],"title":"[CSAPP]第九章 虚拟内存","uri":"/csapp_chapter9/"},{"categories":["读书笔记"],"content":"从处理器加电开始，直到你断电为止，程序计数器假设一个值的序列 $$ a_0,a_1,…a_{n-1} $$ 其中，每个$a_k$是某个相应的指令$I_k$的地址。每次从$a_k$到$a_{k+1}$的过渡称为控制转移(control transfer)。这样的控制转移序列叫做处理器的控制流(flow of control, or control flow)。 最简单的一种控制流式一个“平滑的”序列，其中每个$I_k$和$I_{k+1}$在内存中都是相邻的。这种平滑流的突变（也就是$I_k$和$I_{k+1}$不相邻）通常是由诸如跳转、调用和返回这样一些熟悉的程序指令造成的。 但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，硬件定时器产生的信号、网络事件等。 现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流（Exceptional Control Flow，ECF）。异常控制流发生在计算机系统的各个层次，如硬件层、操作系统层、应用层。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:0:0","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.1 异常 异常时异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。 **异常(exception)**就是控制流中的突变，用来响应处理器状态中的某些变化。 状态变化称为事件(event)。在任何情况下，当处理器检测到由事件发生时，它就会通过一张叫做**异常表(exception table)**的跳转表，进行一个间接过程调用(异常)，到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序，exception handler)。当异常处理程序完成后，根据引起异常的事件的类型，会发生以下3种情况中的一种： 处理程序将控制返回给当前指令$I_curr$，即当事件发生时正在执行的指令。 处理程序将控制返回给$I_next$，如果没有发生异常将会执行的下一条指令。 处理程序终止被中断的程序。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:1:0","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.1.1 异常处理 系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号(exception number)。其中一些是由处理器的设计者分配(被零除、缺页、内存访问违例灯)，其他由操作系统内核的设计者分配(系统调用、来自外部的I/O信号等)。 在系统启动时，操作系统分配和初始化一张称为异常表的跳转表，表目k包含异常k的处理程序的地址。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:1:1","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.1.2 异常的类别 异常可分为四类：中断(interrupt)、陷阱(trap)、故障(fault)、终止(abort)。 1. 中断 中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。硬件中断的异常处理程序常常称为中断处理程序(interrupt handler)。 2. 陷阱和系统调用 陷阱是有意的异常，是执行一条指令的结果。陷阱最重要的用途是在用户程序和内核之间提供了一个像过程调用一样的接口，叫做系统调用。 3. 故障 故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序。 一个经典的故障示例是缺页异常。 4. 终止 终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。终止处理程序直接将控制返回给一个abort例程，该例程会终止这个应用程序。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:1:2","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.1.2 Linux/x86-64系统中的异常 x86-64定义了256种不同的异常类型。0～31的号码对应的是由Intel架构师定义的异常，因此对任何x86-64系统都是一样的。32～255的号码对应的是操作系统定义的中断和陷阱。 1. Linux/x86-64故障和终止 2. Linux/x86-64系统调用 每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表的偏移量（和异常表不一样）。 在x86-64系统上，系统调用是通过一条称为syscall的陷阱指令来提供的。所有到Linux系统调用的参数都是通过通用寄存器而不是栈传递的。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:1:3","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.2 进程 这里我们将关注进程提供给应用程序的关键抽象： 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统 ","date":"2020-09-20","objectID":"/csapp_chapter8/:2:0","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.2.1 逻辑控制流 每个程序执行时PC(程序计数器)值的序列叫做逻辑控制流，或者简称逻辑流。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:2:1","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.2.2 并发流 一个逻辑流的执行在时间上与另一个重叠，称为并发流(concurrent flow)，这两个逻辑流被称为并发地运行。 多个流并发地执行的一般现象被称为并发(concurrency)。一个进程和其他进程轮流运行的概念称为多任务(multitasking)。一个进程执行它的控制流的一部分的每一时间段叫做时间片(time slice)。因此，多任务也叫做时间分片(time slicing)。 并行流是并发流的真子集。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为并行流(parallel flow)，它们并行地运行(running in parallel)，且并行地执行(paralles execution)。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:2:2","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.2.3 私有地址空间 每个进程都有自己的私有地址空间。 尽管和每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的通用结构。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:2:3","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.2.4 用户模式和内核模式 为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。 处理器通常是用某个控制寄存器的一个**模式位(mode bit)来提供这种功能，改寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式(kernel mode)中(又是也叫超级用户模式supervisor mode)。没有设置模式位时，进程就运行在用户模式(user mod)**中。 Linux提供了一种聪明的机制，叫做/proc文件系统，它允许用户模式进程访问内核数据结构的内容。/proc文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。2.6版本的Linux内核引入了/sys文件系统，它输出关于系统总线和设备的额外的低层信息。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:2:4","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.2.5 上下文切换 操作系统内核使用一种称为**上下文切换(context switch)**的较高层形式的异常控制流来实现多任务。 内核为每一个进程维持一个上下文(context)。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈，和各种内核数据结构，比如描述地址空间的页表(page table)、包含当前进程信息的进程表(process table)、包含进程已打开文件信息的文件表(file table)。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:2:5","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.3 系统调用错误处理 当unix系统级函数遇到错误时，它们通常会返回-1，并设置全局整数变量errno来表示什么出错了。strerror函数返回一个文本串，描述了和某个errno值相关联的错误。 一般的错误检查： if ((pid = fork()) \u003c 0) { fprintf(stderr, \"fork error: %s\\n\", strerror(errno)); exit(0); } 使用error-handling wrappers之后的Fork(首字母大写)代码： void unix_error(char *msg) { fprintf(stderr, \"%s: %s\\n\", msg, strerror(errno)); exit(0); } pid_t Fork(void) { pid_t pid; if ((pid = fork()) \u003c 0) unix_error(\"Fork error\"); return pid; } 本书后面都使用了error-handling wrappers。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:3:0","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.4 进程控制 ","date":"2020-09-20","objectID":"/csapp_chapter8/:4:0","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.4.1 获取进程ID pid_t getpid(void); // caller's PID pid_t getppid(void); // parent PID ","date":"2020-09-20","objectID":"/csapp_chapter8/:4:1","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.4.2 创建和终止进程 从程序员的角度，可以认为进程总是处于下面三种状态中： Running：正在被执行或者等待调度。 Stopped：被挂起(suspended)，不会被调度。 Terminated：3种原因，1)收到信号且其默认行为是终止，2)从主程序返回，3)调用exit函数。 父进程通过调用fork函数来创建一个新的运行的子进程。 通过画进程图可以帮助理解fork函数。进程图是刻画程序语句的偏序的一种简单的前趋图。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:4:2","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.4.3 回收(Reaping)子进程 当一个进程由于某种原因终止后，会保持终止状态，知道被它的父进程回收(reaped)。 一个终止了但还未被回收的进程称为僵死进程(zombie)。 如果一个父进程终止了，内核会安排init进程成为它的孤儿进程的养父。 一个进程可以通过调用waitpid函数来等待它的子进程终止或者停止。 waitpid的内容略。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:4:3","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.4.4 让进程休眠 sleep函数将一个进程挂起一段指定的时间。 pause函数让函数休眠，直到该进程收到一个信号。 unsigned int sleep(unsigned int secs); int pause(void); ","date":"2020-09-20","objectID":"/csapp_chapter8/:4:4","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.4.5 加载并运行程序 execve函数在当前进程的上下文中加载并运行一个新的程序。 程序和进程 A process is a specific instance of a program in execution; a program always runs in the context of some process. The fork function runs the same program in a new child process that is a duplicate of the parent. The execve function loads and runs a new program in the context of the current process. While it overwrites the address space of the current process, it does not create a new process. The new program still has the same PID, and it inherits all of the file descriptors that were open at the time of the call to the execve function. ","date":"2020-09-20","objectID":"/csapp_chapter8/:4:5","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.4.6 利用fork和execve运行程序 略。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:4:6","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.5 信号 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 每种信号类型都对应于某种系统事件。地层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。比如，如果一个进程试图除以0，那么内核就发送给它一个SIGFPE信号。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:5:0","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.5.1 信号术语 传送一个信号到目的进程包含两个步骤：发送信号，接收信号。 一个发出儿没有被接收的信号叫做待处理信号(pending signal)。在任何时刻，一种类型至多只会有一个待处理信号，再来就会被丢弃。一个进程可以有选择性地阻塞接收某种信号。但一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。 一个待处理信号最多只能被接收一次。内核为每个进程在pending位向量中维护着待处理信号的集合，而在blocked位向量中维护着被阻塞的信号集合。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:5:1","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.5.2 发送信号 Unix系统提供了大量向进程发送信号的机制，所有这些机制都是基于**进程组(process group)**这个概念的。 1. 进程组 每个进程都只属于一个进程组。进程组通过一个正整数进程组ID来标识。 默认地，一个子进程和它的父进程同属于一个进程组。getpgrp函数返回当前进程的进程组ID。setpgid函数可以改变进程自己或其他进程的进程组。 2. 用/bin/kill程序发送信号 /bin/kill程序可以向进程发送任意信号。 3. 从键盘发送信号 CTRL+C会导致内核发送一个SIGINT信号到前台进程组的每个进程。 4. 用kill函数发送信号 int kill(pid_t pid, int sig) 5. 用alarm函数发送信号 unsigned int alarm(unsigned int secs)安排内核在secs秒后发送一个SIGALRM信号给调用进程。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:5:2","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.5.3 接收信号 当内核把进程p从内核模式切换到用户模式时，它会检查进程p的未被阻塞的待处理信号的集合（pending\u0026~blocked）。如果这个集合为空，那么内核将控制传递到p的逻辑控制流中的下一条指令。然而，如果集合非空，那么内核选择集合中的某个信号k（通常是最小的k），并且强制p接收信号k。收到这个信号会触发进程采取某种行为。一旦进程完成这个行为，那么控制就传递回p的逻辑控制流中的下一条指令。 每个信号类型都有一个预定义的默认行为，见图8-26。进程可以通过sighandler_t signal(int signum, sighandler_t handler)函数修改和信号相关联的默认行为。SIGSTOP和SIGKILL的默认行为无法修改。 信号处理程序可以被其他信号处理程序中断，如图8-31所示。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:5:3","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.5.4 阻塞和解除阻塞信号 Linux提供阻塞信号的隐式和显式的机制： 隐式阻塞机制：内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。 显式阻塞机制：应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和解除选定的信号。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:5:4","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.5.5 编写信号处理程序 信号处理程序有几个属性使得它们很难推理分析： 处理程序和主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序互相干扰。 如何以及何时接收信号的规则常常有违人的直觉。 不同的系统有不同的信号处理语义。 1. 安全地信号处理 这里给出一些保守的编写处理程序的原则，使得这些处理程序能安全地并发运行： 处理程序要尽可能简单。 在处理程序中只调用异步信号安全的函数（要么是可重入的，要么它不能被信号处理程序中断）。 保存和恢复errno。 阻塞所有的信号，保护对共享全局数据结构的访问。 用volatile声明全局变量。 用sig_atomic_t声明标志。 2. 正确的信号处理 关键思想是如果存在一个未处理的信号就表明至少有一个信号达到了。 不可以用信号来对其他进程中发生的事件计数。 3. 可移植的信号处理 Posix标准定义了sigaction函数，它允许用户在设置信号处理时，明确指定它们想要的信号处理语义。一个更简单的方式是，定义一个包装函数，成为Signal，它调用sigaction。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:5:5","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.5.6 同步流以避免讨厌的并发错误 基本的问题是以某种方式同步并发流，从而得到最大的可行的交错的集合，每个可行的交错都能得到正确的结果。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:5:6","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.5.7 显式地等待信号 介绍了sigsuspend函数。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:5:7","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.6 非本地跳转 C语言提供了一种用户级异常控制流形式，称为非本地跳转(nonlocal jump)，它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。非本地跳转是通过setjmp和longjmp函数来提供的。 #include \u003csetjmp.h\u003e int setjmp(jmp_buf env); int sigsetjmp(sigjmp_buf env, int savesigs); void longjmp(jmp_buf env, int retval); void siglongjmp(sigjmp_buf env, int retval); 非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。 PS：具体代码示例较复杂，还是看书吧。 C++和Java提供的异常机制是较高层次的，是C语言的setjmp和longjmp函数的更加结构化的版本。你可以把try语句中的catch子句看做类似于setjmp函数。相似的，throw语句就类似于longjmp函数。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:6:0","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.7 操作进程的工具 STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。 PS：列出当前系统中的进程（包括僵死进程）。 TOP：打印出关于当前进程资源使用的信息。 PMAP：显式进程的内存映射。 /proc：一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户可以读取这些内容。 ","date":"2020-09-20","objectID":"/csapp_chapter8/:7:0","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["读书笔记"],"content":"8.8 小结 ","date":"2020-09-20","objectID":"/csapp_chapter8/:8:0","tags":["caspp"],"title":"[CSAPP]第八章 异常控制流","uri":"/csapp_chapter8/"},{"categories":["编程语言"],"content":"引言 笔者最近开发了一个服务，功能是缓存股票k线数据，减少redis的压力。每一根k线对应redis里的一个用|分隔的字符串，如\"2020-02-19|186.72|188.06|188.18|186.47|187.28|29997471|5618676305.65|0|0.39|0.80|\"。从redis里拿到字符串之后，对其进行分割，然后转换成结构体，放在内存里作为缓存。rpc接口直接拿内存里的数据返回就可以了。 在测试的过程中，发现了一个奇怪的现象，那就是通过pprof查看内存占用时， 发现除了内存中的结构体区域之外，还有一块大小相近的字符串内存区域。 为了彻底搞清楚以上现象的原因，笔者认为有必要深入了解一下golang中的字符串，因此有了本文。 ","date":"2020-05-24","objectID":"/golang_string/:1:0","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"数据结构 先来看一下string在运行时的结构，其定义在文件src/reflect/value.go中 type StringHeader struct { Data uintptr Len int } 对比一下slice的结构，可以发现它们非常相似。 type SliceHeader struct { Data uintptr Len int Cap int } string比slice少了一个Cap字段，因为string是只读的。 Data字段是个指针，指向底层的字节序列。 当对字符串类型使用赋值操作时，目标字符串和源字符串会共享底层的字节序列。 s1 := \"hello world\" s2 := s1 s3 := s1[:5] x1 := (*reflect.StringHeader)(unsafe.Pointer(\u0026s1)) x2 := (*reflect.StringHeader)(unsafe.Pointer(\u0026s2)) x3 := (*reflect.StringHeader)(unsafe.Pointer(\u0026s3)) 上面的代码中，\u0026s1和\u0026s2是不相等的，但是x1.Data和x2.Data是相等的。当我们使用语法aString[start:end]来获取子串的时候，也会共享底层的字节序列，因此x1.Data和x3.Data是相等的。 ","date":"2020-05-24","objectID":"/golang_string/:2:0","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"string、unicode、utf8、rune 要深入了解golang中的字符串，绕不开这几个概念。下面依次介绍一下。 unicode是一套业界标准，它包括「字符集」和「编码方案」等内容。它为每一个「字符」定义唯一的代码，这个唯一的代码叫做code point。 下面来举例。英文字母a的code point是U+0061，中文好的code point是U+597D。unicode还支持组合字符(combining character)，通过多个code point来组成一个组合字符，比如é可以由U+0065(e)和U+0301(´)这两个code point组合来表示。同时，为了兼容性，unicode里还有一些预组合字符(precomposed character)，比如é有单独的code pointU+00E9。 unicode定义的code point的范围从U+0000到U+10FFFF，对应的编码方案有多种，包括UTF-8、UTF-16、UTF-32等。UTF-8使用1~4个字节来编码一个code point。 下面来举例。英文字母a的code point是U+0061，UTF-8编码为0x61。中文好的code point是U+597D，UTF-8编码为0xE5A5BD。 下面来聊聊golang中的string、byte、string literal、rune这几个概念。 byte对于我们开发人员来说是最熟悉不过的了，1 byte=8 bits。golang中的byte是uint8的别名。 string是只读的slice of bytes，可以包含任意的字节，并不要求必须是UTF-8格式的。 string literal中文名是字符串字面量。golang中的string literal是那些直接写在源代码中的字符串，也就是源代码中通过双引号或者反引号定义的字符串。因为golang的源代码都是UTF-8的，所以golang中的字符串字面量基本上都是UTF-8的，比如\"abc\"这种常规的字符串字面量。像\"\\xbd\\xb2\"这种使用\\xNN格式、故意写成非UTF8编码的字面量，也是合法的字符串字面量。 rune是golang中对code point的简称，也是int32的别名。 ","date":"2020-05-24","objectID":"/golang_string/:3:0","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"类型转换 string和[]byte之间能够进行显式的类型转换。 string和[]rune之间也能够进行显式的类型转换。 来看下面这个示例程序 package main import \"fmt\" func main() { s := \"Hello, 世界\" fmt.Printf(\"%+v\\n\", s) fmt.Printf(\"%+v\\n\", []byte(s)) fmt.Printf(\"%+v\\n\", string([]byte(s))) fmt.Printf(\"%+v\\n\", []rune(s)) fmt.Printf(\"%+v\\n\", string([]rune(s))) } 它的结果如下 Hello, 世界 [72 101 108 108 111 44 32 228 184 150 231 149 140] Hello, 世界 [72 101 108 108 111 44 32 19990 30028] Hello, 世界 需要注意的是，以上的类型转换都会发生内存拷贝。因此在高并发场景下，使用这些强制类型转换，性能上会比较差。 []byte-\u003estring调用了runtime.slicebytetostring string-\u003e[]byte调用了runtime.stringtoslicebyte []rune-\u003estring调用了runtime.slicerunetostring string-\u003e[]rune调用了runtime.stringtoslicerune 有兴趣的同学可以去看看源码，一般来说我们知道这种转换会发生内存拷贝就够了。 另外，在某些场景下，编译器对string和byte slice之间的转换做了优化，不会发生拷贝，比如在for-range loop中将string转换成byte slice(for i, b := range []byte(s) {})。 ","date":"2020-05-24","objectID":"/golang_string/:4:0","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"拼接 golang中拼接字符串的方式有很多种，相关的文章也很多。各种拼接方式的性能会受待拼接字符串的长度和数量影响，要全面测试比较困难。这里主要介绍各种拼接方式的实现原理，因此只针对拼接10个、10000个短字符串进行了性能测试。 benchmark测试代码在这个gist中。笔者在自己的笔记本（2.5 GHz Intel Core i7）上测试了一下，结果如下： BenchmarkJoin10-4 9577982 125 ns/op 112 B/op 1 allocs/op BenchmarkSprintf10-4 4068709 297 ns/op 112 B/op 1 allocs/op BenchmarkConcat10-4 2534871 482 ns/op 608 B/op 9 allocs/op BenchmarkBytesBuffer10-4 4680453 255 ns/op 320 B/op 3 allocs/op BenchmarkBytesBufferWithGrow10-4 5702677 218 ns/op 224 B/op 2 allocs/op BenchmarkStringBuilder10-4 6260330 193 ns/op 240 B/op 4 allocs/op BenchmarkStringBuilderWithGrow10-4 13437114 86.7 ns/op 112 B/op 1 allocs/op BenchmarkJoin10000-4 10000 109380 ns/op 106693 B/op 1 allocs/op BenchmarkSprintf10000-4 3282 335898 ns/op 629595 B/op 25 allocs/op BenchmarkConcat10000-4 16 68492777 ns/op 531099348 B/op 10015 allocs/op BenchmarkBytesBuffer10000-4 8527 143114 ns/op 423706 B/op 13 allocs/op BenchmarkBytesBufferWithGrow10000-4 10000 101874 ns/op 213143 B/op 2 allocs/op BenchmarkStringBuilder10000-4 8168 133852 ns/op 522409 B/op 23 allocs/op BenchmarkStringBuilderWithGrow10000-4 19359 60950 ns/op 106591 B/op 1 allocs/op （PS：如果选取的测试字符串太短的话，有可能会被golang优化到没有内存分配。上面的测试选择的字符串长度适中，能够避开golang对短字符串拼接的优化。） 从中我们可以看出，Join、BytesBufferWithGrow和StringBuilderWithGrow是性能最好的，耗时短且内存分配少。下面逐个分析一下。 ","date":"2020-05-24","objectID":"/golang_string/:5:0","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"+ 拼接字符串最简单的方式就是使用+。这也是我们的测试中性能最差的方式。 通过+来进行字符串拼接，编译器会将原始代码转换成通过函数cmd/compile/internal/gc.addstr来生成拼接字符串的代码。这个函数帮助我们在编译期间选择合适的函数来拼接字符串，但最终都会调用函数runtime.concatstrings。这个函数中，一般都会先分配一块能够容纳所有待拼接字符串的内存空间，然后通过调用copy函数来组装最终的字符串。 那么为什么这种拼接方式在测试中的表现最差呢？这是因为编译器转换代码是按语句来操作的。我们在for循环来使用+拼接所有字符串，因此对长度为n的字符串数组来说，要进行n次内存分配。因此性能差。 在已知待拼接字符串数量的时候，将其代码写在一行，如s := s1 + s2 + s3，其性能是非常高的，因为只有一次内存分配。在这种场景下，语法简单，性能又好，推荐使用。 ","date":"2020-05-24","objectID":"/golang_string/:5:1","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"fmt.Sprintf 其源码如下： func Sprintf(format string, a ...interface{}) string { p := newPrinter() p.doPrintf(format, a) s := string(p.buf) p.free() return s } fmt.Sprintf的内部实现中，通过newPrinter函数创建了工具类fmt.pp(维护打印状态)，通过其doPrintf函数来完成字符串的拼接。p.doPrintf函数中的主要原理就是遍历format字符串，找到其中的%，然后根据后面的动词将对应的参数变量转换成字符串，然后继续遍历直到结束。 p.doPrintf函数内部最终是通过p.buf.writeString来拼接字符串。其代码如下： // Use simple []byte instead of bytes.Buffer to avoid large dependency. type buffer []byte func (b *buffer) writeString(s string) { *b = append(*b, s...) } 因此，其内存分配次数是取决于slice的grow策略的。 ","date":"2020-05-24","objectID":"/golang_string/:5:2","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"bytes.Buffer bytes.Buffer会根据输入的数据长度来动态申请内存。其内部结构很简单，主要就是一个byte slice。其源码如下： type Buffer struct { buf []byte // contents are the bytes buf[off : len(buf)] off int // read at \u0026buf[off], write at \u0026buf[len(buf)] lastRead readOp // last read operation, so that Unread* can work correctly. } 测试中的BytesBufferWithGrow和BytesBuffer唯一的区别就是BytesBufferWithGrow会提前调用grow函数分配足够长度的内存。通过其测试结果对比可以看出，此举能够提升性能。 ","date":"2020-05-24","objectID":"/golang_string/:5:3","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"strings.Builder strings.Builder是go在1.10版本中加入的，也是官方推荐的用于拼接字符串的结构。 它的内部结构非常简单，基本就是一个byte slice。所有的操作都是基于这个byte slice。其源码如下： type Builder struct { addr *Builder // of receiver, to detect copies by value buf []byte } 从测试结果中可以看出，虽然底层实现都是byte slice，但在提前使用grow函数申请内存的场景下，strings.Builder比bytes.Buffer要少了一次内存分配，性能也更好一些。原因在于我们最后都调用了它们的String方法来获取最终的字符串。bytes.Buffer的String方法会将byte slice强制转换成string，结合文章前面的内容我们知道，这一步是要进行内存拷贝的。而strings.Builder的string方法使用了unsafe.Pointer来将byte slice转换成string，避免了内存拷贝。 func (b *Buffer) String() string { if b == nil { // Special case, useful in debugging. return \"\u003cnil\u003e\" } return string(b.buf[b.off:]) } func (b *Builder) String() string { return *(*string)(unsafe.Pointer(\u0026b.buf)) } ","date":"2020-05-24","objectID":"/golang_string/:5:4","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"strings.Join 其内部实现使用了strings.Builder，并在开始就通过Grow函数预分配了待拼接字符串长度和的内存，因此性能很好。 ","date":"2020-05-24","objectID":"/golang_string/:5:5","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"总结 通过以上分析，我们可以看出，影响字符串拼接性能的主要因素就是内存分配次数。无论使用哪种拼接方式，尽量减少内存分配次数，就能获取更好的性能。 如果有拼接非字符串或者特殊格式化的需求，那么估计只能选择fmt系列函数。如果编译时能够确定待拼接字符串数量，那么在一行内使用+将其拼接起来是既方便又高效的。其他场景，使用strings.Buider一般都是最好的选择。 ","date":"2020-05-24","objectID":"/golang_string/:5:6","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"遍历 golang中遍历字符串，我们一般都会使用for-range loop。需要注意的是，使用for-range来遍历字符串时，我们拿到的值都是rune类型的变量，而不是byte。for v1, v2 := range a {}会在编译时转换成如下形式的代码： ha := a for hv1 := 0; hv1 \u003c len(ha); { hv1t := hv1 hv2 := rune(ha[hv1]) if hv2 \u003c utf8.RuneSelf { hv1++ } else { hv2, hv1 = decoderune(ha, hv1) } v1, v2 = hv1t, hv2 // original body } 当我们使用下标的方式来遍历字符串时，像for i = 0; i \u003c len(s); i++ {}，s[i]是byte类型的变量，这种情况就是把字符串当作是字节数组来使用了。 ","date":"2020-05-24","objectID":"/golang_string/:6:0","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"字符串比较 当我们使用==或者!=来比较两个字符串的时候，如果它们底层的字节序列地址相同，那么可以通过比较其长度来判断其是否相等，时间复杂度是O(1)。如果底层的字节序列地址不同，那么时间复杂度就是O(n)了。 感兴趣的可以看一下汇编源码 ","date":"2020-05-24","objectID":"/golang_string/:7:0","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"使用字符串内部化来优化空间占用 字符串内部化(string intern)是指一种让相同的字符串在内存中只保存一份的技术。对于要存储大量字符串的应用来说，它可以显著降低内存占用。 通过前述分析，我们知道golang中的字符串结构体为StringHeader。其中的Data是一个指向底层字节序列的地址。两个字符串变量在内存中的地址虽然不同，但它们的底层字节序列的地址可以相同。 golang对于在编译期间可以确定的字符串常量，会进行内部化处理。如果是运行期间产生的字符串，则无法内部化。 // 可以被intern，底层字节序列地址相同 s1 := \"12\" s2 := \"1\"+\"2\" // 不能被intern，底层字节序列地址不同 s3 := \"12\" s4 := strconv.Itoa(12) 了解这些之后，我们可以想办法绕过限制，在运行时手动完成字符串内部化。一个简单的实现如下： package main import ( \"fmt\" \"reflect\" \"strconv\" \"unsafe\" ) // stringptr returns a pointer to the string data. func stringptr(s string) uintptr { return (*reflect.StringHeader)(unsafe.Pointer(\u0026s)).Data } type stringInterner map[string]string func (si stringInterner) Intern(s string) string { if interned, ok := si[s]; ok { return interned } si[s] = s return s } func main() { si := stringInterner{} s1 := si.Intern(\"12\") s2 := si.Intern(strconv.Itoa(12)) fmt.Println(stringptr(s1) == stringptr(s2)) // true } 其原理很简单，就是自己维护一个字符串的池子，在程序中只使用池子中的字符串。在缓存类的应用中，使用该技术可以节省很多内存空间。 golang在net包中也使用了该技术： // commonHeader interns common header strings. var commonHeader map[string]string var commonHeaderOnce sync.Once func initCommonHeader() { commonHeader = make(map[string]string) for _, v := range []string{ \"Accept\", \"Accept-Charset\", \"Accept-Encoding\", // ... } { commonHeader[v] = v } } ","date":"2020-05-24","objectID":"/golang_string/:8:0","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"结语 结合以上内容，就可以解决文章开头遇到的问题。在将redis中的k线字符串转换为结构体的时候，结构体引用了字符串split之后的第一个表示日期的子串，因此导致原始字符串的底层的字节序列未被回收，一直驻留在内存中。使用字符串内部化技术，可以很简单的解决问题，同时减少内存占用。 以文章开头的字符串\"2020-02-19|186.72|188.06|188.18|186.47|187.28|29997471|5618676305.65|0|0.39|0.80|\"为例。通过阅读strings.Split的源码可知，它是通过设置offset，复用底层字节数组来生成的子字符串。 func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) } func genSplit(s, sep string, sepSave, n int) []string { if n == 0 { return nil } if sep == \"\" { return explode(s, n) } if n \u003c 0 { n = Count(s, sep) + 1 } a := make([]string, n) n-- i := 0 for i \u003c n { m := Index(s, sep) if m \u003c 0 { break } a[i] = s[:m+sepSave] s = s[m+len(sep):] i++ } a[i] = s return a[:i+1] } 在strings.Split之后，我们能够获取一个字符串数组，暂命名其为kFields。然后将kFields的各个值分别赋给结构体的各个字段。kFields[0]是日期，仍然被保留为string类型。其他字段都需要进行到数字的转换。因此，只有kFields[0]一直被引用着，也就导致原始字符串的底层字节序列一直被引用，无法被垃圾回收，也就一直占用着内存。通过内部化技术解除对kFields[0]的引用之后，原始字符串的底层字节序列也可以被回收掉了，内存占用也就降下来了。 以上就是笔者通过实际问题，逐渐深入内部原理，然后对golang中字符串的相关内容进行的梳理。如有错误之处，敬请指正。 ","date":"2020-05-24","objectID":"/golang_string/:9:0","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["编程语言"],"content":"参考资料 Strings, bytes, runes and characters in Go Basic Types and Basic Value Literals Strings in Go String interning in Go 聊一聊字符串内部化 【Go】string 优化误区及建议 Go语言字符串高效拼接 ","date":"2020-05-24","objectID":"/golang_string/:10:0","tags":["golang"],"title":"聊聊Golang中的字符串","uri":"/golang_string/"},{"categories":["读书笔记"],"content":"链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载(复制)到内存并执行。 执行时机： 编译时(compiler time)，即源代码被翻译成机器代码时 加载时(load time)，即程序被加载器(loader)加载到内存并执行时 运行时(run time)，即有运行程序来执行 现代系统中，链接时由叫做链接器(linker)的程序自动执行的。链接使得分离编译(seperate compliation)成为可能。 此后的讨论基于linux-64系统下标准的ELF-64目标文件格式。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:0:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.1 编译器驱动程序 示例程序： // main.c int sum(int *a, int n); int array[2] = {1, 2}; int main() { int val = sum(array, 2); return val; } // sum.c int sum(int *a, int n) { int i, s = 0; for (i =0; i \u003c n; i++) { s += a[i]; } return s; } 大多数编译系统提供编译器驱动程序(compiler driver)，它代表用户在需要时调用语言预处理器、编译器、汇编器、链接器。使用GNU编译系统构造示例程序，可以用命令gcc -Og -o prog main.c sum.c 上图概括了驱动程序将示例程序从ASCII码源文件翻译成可执行目标文件时的行为。过程包括： 运行C预处理器(C preprocessor, cpp)，将main.c翻译成一个ASCII码的中间文件(intermedia file)main.i 运行C编译器(C compiler, cc1)，将main.i翻译成ASCII码汇编语言文件main.s 运行汇编器(assembler, as)，将main.s翻译成一个可重定位目标文件(relocatable object file)main.o 经历上述相同过程生成sum.o 运行链接器程序(linker, ld)，将main.o和sum.o以及一些必要的系统文件组合起来，创建一个可执行目标文件(executable object file)prog 在shell中执行./porg可运行prog。shell调用操作系统中一个叫做加载器(loader)的函数，它将可执行文件prog中的代码和数据复制到内存，然后将控制转移到这个程序的开头。 cpp [other options] main.c /tmp/main.i cc1 /tmp/main.i -Og [other options] -o /tmp/main.s as [other options] -o /tmp/main.o /tmp/main.s ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o ","date":"2020-03-22","objectID":"/csapp_chapter7/:1:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.2 静态链接 像Linux LD程序这样的静态链接器(static linker)以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件是由各种不同的代码和数据节(section)组成，每一节都是一个连续的字节序列。 为了构造可执行文件，链接器必须完成两个主要任务： 符号解析(symbol resolution)。目的是将每个符号引用正好和一个符号定义关联起来。 重定位(relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存地址位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:2:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.3 目标文件 目标文件由三种形式： 可重定位目标文件：包含二进制代码和数据。其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。 可执行目标文件：包含二进制代码和数据。其形式可以被直接复制到内存并执行。 共享目标文件：可以在加载或运行时被动态地加载进内存并链接。 编译器和汇编器生成可重定位目标文件(包括共享目标文件)。链接器生成可执行目标文件。 各个系统的目标文件格式都不相同。现代Linux系统使用可执行可链接格式(Executable and Linkable Format, ELF)。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:3:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.4 可重定位目标文件 ELF header以一个16字节的序列(描述了系统字长和字节顺序)开始，剩下的部分包含的信息可帮助链接器进行语法分析和解析目标文件。 section header table描述了不同节的位置和大小，每个节都有一个固定大小的条目(entry)。 ELF header和section header table之间是不同的节： .text: 已编译程序的机器代码 .rodata: read-only data，如printf中的格式串和switch语句中的跳转表 .data: 已初始化的全局和静态C变量 .bss: 未初始化的全局和静态C变量，以及所有被初始化未0的全局或静态变量。不占实际空间，只是占位符。Block Storage Start，简单记法为Better Save Space。 .symtab: symbol table，存放程序中定义和引用的函数和全局变量信息。注意，并不包含局部变量 .rel.text: 一个.text section中的位置列表，链接器组合目标文件时需要修改这些位置 .rel.data: 被module引用或定义的所有全局变量的重定位信息。 .debug: debugging symbol table，其条目时程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件 .line: 原始C源程序中的行号和.text section中机器指令之间的映射 .strtab: string table，其内容包括.symtab和.debug中的符号表，以及section headers中的section name。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:4:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.5 符号和符号表 在链接器的上下文中，有三种不同的符号： 由模块m定义并能被其他模块引用的全局符号，对应nonstatic C functions and global variables 由其他模块定义并被模块m引用的全局符号，对应其他模块中的nonstatic C functions and global variables 只能被模块m定义和引用的局部符号，对应static C functions and global variables、 .symtab中并不包含local nonstatic变量，因为它们在运行时在栈中被管理，链接器对这类符号不感兴趣。 符号表是由汇编器通过使用编译器输出到汇编语言.s文件中的符号构造的。.symtab section中包含ELF符号表，它包含an array of entries。entry的结构如下： typedef struct { int name; \\* String table offset *\\ char type:4, \\* Function or data (4 bits) *\\ binding:4; \\* Local or global (4 bits) *\\ char reserved; \\* Unused *\\ short section; \\* Section header index*\\ long value; \\* Section offset or absolute address *\\ long size; \\* Object size in bytes *\\ } Elf64_Symbol; 每个符号都被分配到目标文件的某个section，由section字段表示。有三个特殊的伪节(pseudosection)，它们在section header table中没有条目：ABS代表不该被重定位的符号；UNDEF代表未定义的符号，也就是在本module中引用，但在其他地方定义的符号；COMMON表示还未被分配位置的未初始化的数据目标。 COMMON和.bss的区别： COMMON: 未初始化的全局变量 .bss: 未初始化的静态变量，以及初始化为0的全局或静态变量 GNU READELF程序是一个方便查看目标文件内容的工具。下图是示例程序main.o的符号表的最后三个条目： Ndx=1表示.text section，Ndx=3表示.data section ","date":"2020-03-22","objectID":"/csapp_chapter7/:5:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.6 符号解析 链接器解析符号引用的方法是，将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。每个模块中每个local symbol只能由一个定义，解析较简单。 对global symbol的解析就麻烦了。当编译器遇到一个不是在当前模块中定义的符号(变量或函数)时，会假设该符号是在其他某个模块中定义的，然后生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用的符号的定义，就输出一条错误信息并终止。 对全局符号的符号解析很棘手，还因为多个目标文件可能会定义相同名字的全局符号。在这种情况中，链接器必须要么报错，要么选出一个定义并抛弃其他定义。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:6:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.6.1 链接器如何解析多重定义的全局符号 链接器的输入是一组可重定位目标文件。 在编译时，编译器向汇编器输出每个全局符号，要么强(strong)要么弱(weak)，汇编器再把这个信息隐含地编码再可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。 根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名： 规则1: 不允许有多个同名的强符号。 规则2: 如果有一个强符号和多个弱符号同名，那么选择强符号。 规则3: 如果有多个弱符号同名，那么从这些弱符号中任意选择一个。 规则2和规则3会造成一些不易察觉的运行时错误，尤其是如果重复的符号定义还有不同的类型时。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:6:1","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.6.2 与静态库链接 迄今为止，我们都是假设链接器读取一组可重定位目标文件，并把它们链接起来，形成一个输出的可执行文件。实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，成为静态库(static library)，它可以用作链接器的输入。当链接器构造一个输出的可执行文件时，它只是复制静态库中被应用程序引用的目标模块。 为什么系统要支持库的概念？ 大部分系统都定义了一组广泛的I/O、字符串操作和整数数学函数。如果不使用静态库，那么编译器开发人员要使用什么方方法来向用户提供这些函数呢？ 让编译器辨认出对标准函数的调用，并直接生成相应的代码。这种方法将给编译器增加显著的复杂性，而且每次添加、删除或修改一个标准函数时，需要更新编译器版本。 将所有的标准函数都放在一个单独的可重定位目标模块中，应用程序员可以把这个模块链接到他们的可执行文件中。缺点是系统中每个可执行文件都包含一份标准函数集合的完全副本，浪费硬盘和内存。另一个缺点是标准函数的任何变动，都要求库的开发人员重新编译整个源文件，费时费力。 为每个标准函数创建一个独立的可重定位文件，并存放在约定好的目录。缺点是要求应用程序员显式地链接合适的目标模块到它们的可执行文件中，耗时且易出错。 静态库概念被提出来，以解决这些不同方法的缺点。 相关的函数可以被编译为独立的目标模块，然后封装称一个单独的静态库文件。然后，应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数。比如，使用C标准库和数学库中函数的程序可以用如下的命令行来编译和链接： linux\u003e gcc main.c /use/lib/libm.a /usr/lib/libc.a 在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字。 在Linux系统中，静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀.a标识。（备注：.a文件是一组.o文件的集合） 后面的讨论基于图7-6中的代码。 为了使用这个库，我们编写一个应用，如图7-7。 图7-8概括了链接器的行为。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:6:2","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.6.3 链接器如何使用静态库来解析引用 在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。 这种算法会导致一些令人困惑的链接时错误，因为顺序很重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。 关于库的一般准则是将它们放在命令行的结尾。如果库互相独立，那么顺序任意。如果库不是互相独立，那么必须对它们排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义是在对s的引用之后的。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:6:3","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.7 重定位 一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并数据模块，并为每个符号分配运行时地址。 重定位由两步组成： 重定位节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的.data节被全部合并成一个节，这个节称为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为**重定位条目(relocation entry)**的数据结构。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:7:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.7.1 重定位条目 当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，高速链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条放在.rel.text中，已初始化数据的重定位条目放在.rel.data中。 typedef struct { long offset; /* Offset of the reference to relocate */ long type:32, /* Relocation type */ symbol:32; /* Symbol table index */ long addend; /* Constant part of relocation expression */ } Elf64_Rela; ELF定义了32种不同的重定位类型，我们只关心两种最基本的： R_X86_64_PC32。重定位一个使用32位PC相对地址的引用。 R_X86_64_32。重定位一个使用32位绝对地址的引用。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:7:1","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.7.2 重定位符号引用 图7-10是链接器的重定位算法的伪代码。其中，s是secion，r是relocation entry。 图7-11给出了main.o的反汇编代码。 1. 重定位PC相对引用 图7-11的第6行，main调用sum。 假定链接器已经确定 ADDR(s) = ADDR(.text) = 0x4004d0 ADDR(r.symbol) = ADDR(sum) = 0x4004e8 2. 重定位绝对引用 图7-11的第4行种，mov将array的地址复制到%edi中。 假定链接器已经确定 ADDR(r.symbol) = ADDR(array) = 0x601018 综合起来，图7-12给出了最终可执行目标文件中已重定位的.text节和.data节。在加载的时候，加载器会把这些节中的字节直接复制到内存，不再进行任何修改地执行这些指令。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:7:2","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.8 可执行目标文件 图7-13概括了一个典型的ELF可执行文件中的各类信息。 ELF头描述文件的总体格式。它还包括程序的入口点(entry point)，也就是当程序运行时要执行的第一条指令的地址。 因为ELF可执行文件是完全链接的(已被重定位)，所以它不再需要.rel节。.test、.rodata、.data节也都已重定位到它们最终的运行时内存地址。 ELF可执行文件被设计得很容易加载到内存，可执行文件的连续的片(chunk)被映射到连续的内存段。程序头部表(program header table)描述了这种映射关系。 图7-14展示了可执行文件prog的程序头部表。 从中可以看出，根据可执行目标文件的内容初始化了两个内存段。 第1、2行，代码段，有读/执行权限(rx)，开始于内存地址0x400000，总共占用内存大小0x69字节，并且被初始化位可执行目标文件的头0x69c个字节，其中包括ELF头、程序头部表以及.init、.text和.rodata节。 第3、4节，数据段，有读/写权限(rw)，开始于内存地址0x600df8，总共占用内存大小0x230字节，并且从目标文件中偏移0xdf8处开始的.data节中的0x228个字节初始化。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:8:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.9 加载可执行目标文件 通过在shell中执行./prog可以运行可执行目标文件prog。 因为它不是内置的shell命令，shell会认为prog是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器(loader)的操作系统代码来运行它。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个奖程序复制到内存并运行的过程叫做加载。 每个Linux程序都有一个运行时内存映像，类似于图7-15。 在Linux x86-64系统中，代码段重视从地址0x400000处开始，后面是数据段。运行时堆在数据段之后，通过调用malloc库往上增长。堆后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址($2^{48}-1$)开始，向较小内存地址增长。栈上的区域，从地址$2^{48}$开始，是为内核中的代码和数据保留的。 为了简洁，我们把堆、数据和代码段画得彼此相邻，并且把栈顶放在了最大的合法用户地址处。是加上，由于.data段有对齐要求，代码段和数据段之间是有间隙的。同时，在分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间布局随机化(ASLR)。虽然每次程序运行时这些区域的地址都会变，但它们的相对位置是不变的。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:9:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.10 动态链接共享库 静态库有一些明显的缺点： 需要定期维护和显示地更新。 像printf这种函数代码会被复制到每个运行进程的文本段中，浪费内存。 共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接(dynamic linking)，是由一个叫做动态链接器(dynamic linker)的程序来执行的。共享库也称为共享目标(shared object)，在Linux系统中通常用.so后缀来表示。windows中称为DDL。 共享库是以两种不同的方式来“共享”的： 在任何给定的文件系统中，对于一个库只有一个.so文件。所有引用该库的可执行目标文件共享这个.so文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。 在内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。 图7-16概括了图7-7中示例程序的动态链接过程。 可执行目标文件prog21在运行时可以和libvector.so链接。基本思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:10:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.11 从应用程序中加载和链接共享库 应用程序可以在它运行时要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接到应用中。 动态链接是一项强大有用的技术。可以用来构建高性能web服务器。其思路是将每个生成动态内容的函数打包在共享库中。当一个来自web浏览器的请求到达时，服务器动态地加载和链接适当的函数，然后直接调用它，而不是使用fork和execve在子进程的上下文中运行函数。函数会一直缓存在服务器的地址空间中，所以只要一个简单的函数调用的开销就可以处理随后的请求了。在运行时无需停止服务器，就可以更新已存在的函数，以及添加新的函数。 Linux系统为动态链接器提供了简单的接口，允许应用程序在运行时加载和链接共享库。 图7-17展示了如何利用这个接口动态链接我们的libvector.so共享库，然后调用它的addvec例程。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:11:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.12 位置无关代码 共享库的一个主要目的是允许多个正在运行的进程共享内存中相同的库代码，因而节约宝贵的内存资源。那么，多个进程是如何共享程序的一个副本的呢？ 一种方法是给每个共享库分配一个实现预备的专用的地址空间片，然后要求加载器总是在这个地址记载共享库。这种方法虽简单，但也造成了一些严重的问题。它对地址空间的使用效率不高，即使没有进程使用这个库，地址空间还是会被分配。它也难以管理，我们必须保证没有片会重叠，还要为新库寻找地址空间。 要避免这些问题，现在系统编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需被链接器修改。使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本。(当然，每个进程仍然会有它自己的读/写数据段) 可以加载而无需重定位的代码称为位置无关代码(Position-Independent Code, PIC)。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:12:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"1. PIC数据引用 编译器通过以下事实来生成对全局变量的PIC引用： 无论我们在内存中的何处加载一个目标模块(包括共享目标模块)，数据段和代码段之间的距离总是保持不变。因此，代码段中任何指令和数据段中的任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的。 想要生成对全局变量PIC引用的编译器利用了这个事实，它在数据段开始的地方创建了一个表，叫做全局偏移量表(Global Offset Table, GOT)。编译器为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:12:1","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"2. PIC函数调用 GNU编译系统使用延迟绑定(lazy binding)，将过程地址的绑定推迟到第一次调用该过程时。 延迟绑定时通过GOT和PLT(过程链接表，Procedure Linkable Table)这两个数据结构来实现的。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:12:2","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.13 库打桩机制 Linux链接器支持一个很强大的技术，称为库打桩(library interpositioning)。它允许你截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，你可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入和输出，或者把它替换成一个完全不同的实现。 基本思想：给定一个需要打桩的目标函数，创建一个包装函数，它的原型与目标函数完全一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。保证函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。 打桩可以发生在编译时、链接时或者当程序被加载和执行的运行时。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:13:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.13.1 编译时打桩 图7-20展示了如何使用C预处理器在编译时打桩。 \u003e gcc -DCOMPILETIME -c mymalloc.c \u003e gcc -I. -o intc int.c mymalloc.o 由于有-I.参数，所以会进行打桩，它告诉C预处理器在搜索通常的系统目录之前，先在当前目录中查找malloc.h。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:13:1","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.13.2 链接时打桩 Linux静态链接器支持用--wrap f标志进行链接时打桩。这个标志告诉链接器，把对符号f的引用解析成__wrap_f(前缀是两个下划线)，还要把对符号__real_f(前缀是两个下划线)的引用解析为f。 图7-21给出我们示例程序的包装函数。 \u003e gcc -DLINKTIME -c mymalloc.c \u003e gcc -c int.c \u003e gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o ","date":"2020-03-22","objectID":"/csapp_chapter7/:13:2","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.13.3 运行时打桩 编译时打桩需要能够访问程序的源代码，链接时打桩需要能够访问程序的可重定位目标文件。运行时打桩基于动态链接器的LD_PRELOAD环境变量。 如果LD_PRELOAD环境变量被设置为一个共享库路径名的列表，那么当你加载和执行一个程序，需要解析未定义的引用时，动态链接器(LD-LINUX.so)会先搜索LD_PRELOAD库，然后才搜索任何其他的库。有了这个机制，当你加载和执行任何可执行文件时，可以对任何共享库中的任何函数打桩，包括libc.so。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:13:3","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"7.14 处理目标文件的工具 GNU binutils包可以运行在每个Linux平台上： AR：创建静态库，插入、删除、列出、提取成员。 STRINGS：列出一个目标文件中所有可打印的字符串。 STRIP：从目标文件中删除符号表信息。 NM：列出一个目标文件的符号表中定义的符号。 READELF：显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能。 OBJDUMP：所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用时反汇编.text节中的二进制指令。 Linux中的LDD：列出一个可执行文件在运行时所需要的共享库。 ","date":"2020-03-22","objectID":"/csapp_chapter7/:14:0","tags":["caspp"],"title":"[CSAPP]第七章 链接","uri":"/csapp_chapter7/"},{"categories":["读书笔记"],"content":"6.1 存储技术 ","date":"2020-02-09","objectID":"/csapp_chapter6/:1:0","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.1.1 随机访问存储器 1. 静态RAM SRAM，有电就保持不变，贵。 2. 动态RAM DRAM，需要刷新。 3. 传统的DRAM 电路设计者将DRAM组织成二维阵列，而不是线性数组。一个原因是降低芯片上地址引脚的数量。确定是必须分两步发送地址，增加了访问时间。 4. 内存模块 DRAM芯片封装在内存模块(memory module)中，它插到主板的扩展槽上。 5. 增强的DRAM 略。 6. 非易失性存储器 整体上被称为只读存储器(Read-Only Memory, ROM)。 还介绍了闪存(flash memory)和固态硬盘(Solid State Disk, SSD)。 7. 访问主存 数据流通过称为总线(bus)的共享电子电路在处理器和DRAM主存之间来来回回。每次CPU和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为总线事务(bus transactoin)，分为读事务和写事务。 图6-6展示了一个示例计算机系统的配置。系统总线连接CPU和I/O桥接器，内存总线连接I/O桥接器和主存。 图6-7展示了movq A,%rax这种读事务的三个步骤。 图6-8展示了movq %rax,A这种写事务的三个步骤。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:1:1","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.1.2 磁盘存储 1. 磁盘构造 2. 磁盘容量 略。 3. 磁盘操作 磁盘以扇区大小的块来读写数据。对扇区的访问时间(access time)有三个主要的部分：寻道时间(seek time)、旋转时间(retational latency)、传送时间(transfer time)。 4. 逻辑磁盘块 现代磁盘封装中有一个小的硬件/固件设备，称为磁盘控制器，维护着逻辑块号和实际(物理)磁盘扇区之间的映射关系。 (盘面，磁道，扇区)这个三元组唯一地标识了对应的物理扇区。 5.连接I/O设备 图6-11展示了一个典型的I/O总线结构，有三种不同类型的设备连接到总线。 6. 访问磁盘 图6-12总结了当CPU从磁盘读数据时发生的步骤。 CPU使用一种称为内存映射I/O(memory-mapped I/O)的技术来向I/O设备发送命令(图6-12a)。地址空间中又一块地址是为与I/O设备通信保留的，每个这样的地址称为一个I/O端口(I/O port)。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:1:2","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.1.3 固态硬盘 略。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:1:3","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.1.4 存储技术趋势 从上述讨论中可总结出介个重要的思想： 不同的存储技术有不同的价格和性能折中。 不同存储技术的价格和性能属性以截然不同的速率变化着。 DRAM和磁盘的性能之后于CPR的性能。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:1:4","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.2 局部性 一个编写良好的计算机程序常常具有良好的局部性(locality)。也就是，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为局部性原理(principle of locality)，是一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:2:0","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.3 存储器层次结构 存储器层次结构的中心思想是，对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。 数据总是以块大小为传送单元(transfer unit)在第k层和第k+1层之间来回复制的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以有不同的块大小。 缓存不命中的种类： 一个空的缓存有时被称为冷缓存(cold cache)，此类不命中称为冷不命中(cold miss)，也称作强制性不命中(compulsory miss)。 冲突不命中(conflict miss)：某些限制性的放置策略(placement policy)，会将某些对象映射到同一个缓存块，虽然缓存足够大，但一直不命中。 容量不命中(capacity miss)：工作集的大小超过缓存的大小。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:3:0","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.4 高速缓存存储器 ","date":"2020-02-09","objectID":"/csapp_chapter6/:4:0","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.4.1 通用的高速缓存存储器组织结构 考虑一个计算机系统，每个存储器地址有$m$位，形成$M=2^m$个不同的地址。它的告诉缓存被组织成一个有$S=2^s$个高速缓存组(cache set)的数组。每个高速缓存组包含$E$个高速缓存行(cache line)。每行是由一个$B=2^b$字节的数据块(block)组成的，一个有效位(valid bit)指明这个行是否包含有意义的信息，还有$t=m-(b+s)$个标记位(tag bit)(是当前块的内存地址的位的一个子集)，标记位唯一地标识存储在这个高速缓存行中的块。 一般而言，高速缓存的结构可以用元组$(S, E, B, m)$来描述，其容量$C=S \\times E \\times B$，标记位和有效位不含括在内。 高速缓存是如何检测它是否包含一个主存地址A处的数据的副本呢？如图6-25b所示，通过类似于哈希的一种映射来做到。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:4:1","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.4.2 直接映射高速缓存 根据每个组的高速缓存行数$E$，高速缓存被分为不同的类。每个组只有一行的高速缓存称为直接映射高速缓存(direct-mapped cache)。 确定一个请求是否命中，然后抽取出被请求的字的过程，分为三步：组选择、行匹配、字抽取。 1. 直接映射高速缓存中的组选择 通过$s$个组索引位 2. 直接映射高速缓存中的行匹配 通过有效位和标记位 3. 直接映射高速缓存中的字选择 通过偏移量。 4. 直接映射高速缓存中不命中时的行替换 用从下一层中新取出的行替换当前的行。 5. 运行中的直接映射高速缓存 略。 6. 直接映射高速缓存中的冲突不命中 术语抖动(thrash)描述的是这样一种情况，即高速缓存反复地加载和驱逐相同的高速缓存块的组。 可以通过填充来改变映射，从而修正都懂问题。 为什么用中间的位来做索引？ 如果高位用做索引，那么一些连续的内存块就会映射到相同的高速缓存块。这样会导致使用率低。 用中间位作为作引，相邻的块总是映射到不同的高速缓存行。这样使用率高。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:4:2","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.4.3 组相联高速缓存 组相联高速缓存(set associative cache)中每个组都保存多于一个的高速缓存行。一个$1\u003cE\u003cC/B$的高速缓存通常称为$E$路组相联高速缓存。 组选择，通过组索引。 行匹配和字选择。这里一个重要思想就是组中的任何一行都可以包含任何映射到这个组的内存块。所以高速缓存必须搜索组中的每一行，寻找一个有效的行，其标记与地址的标记相匹配。 不命中时的行替换，需要用到LFU、LRU等替换策略。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:4:3","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.4.4 全相联高速缓存 全相联高速缓存(full associative cache)是由一个包含所有高速缓存行的组(即$E=C/B$)组成的。 组选择。因为只有一个组，所以地址中没有组索引位，只有标记位和块偏移。 行匹配和字选择。与组相联一致。 全相联高速缓存只适合做小的高速缓存，例如虚拟内存系统中的翻译备用缓冲器(TLB)，它缓存页表项。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:4:4","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.4.5 有关写的问题 读比较简单，命中就返回，不命中就从下一层找到后存储到本层再返回。 写要复杂一些。 写命中(write hit)，即cache中存在要写的字$w$。在cache更新了它的$w$的副本之后，怎么更新到下一层的副本中呢？ 直写(write-through)：立即将$w$的高速缓存块写回到紧接着的低一层中。简单，但每次写都会引起总线流量。 写回(write-back)：尽可能推迟更新，只有当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中。由于局部性，能显著减少总线流量，但缺点是复杂，要额外维护修改位(dirty bit)。 另一个问题是如何处理写不命中。 写分配(write-allocate)：加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。 非写分配(not-write-allocate)：直接把这个字写到低一层中。 write-through搭配not-write-allocate write-back搭配write-allocate 心里默认采用write-back搭配write-allocate来写程序就好啦。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:4:5","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.4.6 一个真实的高速缓存层次结构中的解剖 只保存指令的高速缓存称为i-cache。 只保存程序数据的高速缓存称为d-cache。 既保存指令又保存数据的高速缓存称为统一的高速缓存(unified cache)。 现代处理器包括独立的i-cache和d-cache。 图6-38给出了Intel Core i7处理器的高速缓存层次结构。 图6-39总结了Core i7高速缓存的基本特性。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:4:6","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.4.7 高速缓存参数的性能影响 衡量性能的指标： 不命中率(miss rate) 命中率(hit rate) 命中时间(hit time)：从cache传送一个字到CPU所需时间。 不命中处罚(miss penalty)：不命中所需要的额外的时间。 影响cache性能的因素包括： cache大小：较大的cache可能会增加命中时间。 块大小 相联度 写策略 ","date":"2020-02-09","objectID":"/csapp_chapter6/:4:7","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.5 编写高速缓存友好的代码 让最常见的情况运行地快 尽量减小每个循环内部的缓存不命中率 对局部变量的反复引用是好的，因为编译器能够将它们缓存在寄存器文件中(时间局部性) 步长为1的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据存储为连续的块(空间局部性) ","date":"2020-02-09","objectID":"/csapp_chapter6/:5:0","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.6 综合：高速缓存对程序性能的影响 ","date":"2020-02-09","objectID":"/csapp_chapter6/:6:0","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.6.1 存储器山 一个程序从存储系统中读数据的速率称为读吞吐量(read throughput)。 图6-40给出了一个测量某个读序列读吞吐量的函数。 run函数的参数size和stride允许我们控制产生出的读序列的时间和空间局部性程度。 size越小，得到的工作集越小，因此时间局部性越好。 stride越小，得到的空间局部性越好。 反复调整size和stride调用run函数，我们就能得到一个读带宽的时间和空间局部性的二维函数，称为存储器山(memory mountain)。 图6-41展示了Intel Core i7系统的存储山。 我们从这座山中取出一个片段，保持stride不变，我们就能很清楚地看到cache的大小和时间局部性对性能的影响。如图6-42所示。 以相反的方向横切这座山，保持size不变，能看到空间局部性对吞吐量的影响。如图6-43所示。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:6:1","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.6.2 重新排列循环以提升空间局部性 略。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:6:2","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"6.6.3 在程序中利用局部性 我们推荐下列技术： 将你的注意力集中在内循环上，大部分计算和内存访问都发生在这里。 通过按照数据对象存储在内存中的顺序、以步长为1来读数据，从而使得你的程序中的空间局部性最大。 一旦从存储器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大。 ","date":"2020-02-09","objectID":"/csapp_chapter6/:6:3","tags":["caspp"],"title":"[CSAPP]第六章 存储器层次结构","uri":"/csapp_chapter6/"},{"categories":["读书笔记"],"content":"编写高效程序需要做到以下几点： 我们必须选择一组适当的算法和数据结构。 我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。 针对处理运算量特别大的计算，将一个任务分解成多个部分，这些部分可以在多核和多处理器的某种组合上并行地计算。（第12章再讲） 通常，程序员必须在实现和维护程序的简单性与它的运行速度之间做出权衡。 为了使程序性能最大化，程序员和编译器都需要一个目标机器的模型，指明如何处理指令，以及各个操作的时序特性。程序员必须理解这些处理器是如何工作的，从而调整他们的程序以获得最大的速度。基于Intel和AMD处理器最近的设计，我们提出了这种机器的一个高级模型。我们还设计了一种图形数据流(data-flow)表示法，可以是处理器对指令的执行形象化，我们还可以利用它预测程序的性能。 了解了处理器的运作，我们就可以进行程序优化的第二步，利用处理器提供的指令级并行(instruction-level parallelism)能力，同时执行多条指令。 研究程序的汇编代码表示是理解编译器以及产生的代码会如何运作的最有效手段之一。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:0:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.1 优化编译器的能力和局限性 现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是被如何使用的。然后会利用一些机会来简化表达式，在几个不同的地方使用同一个计算，以及降低一个给定的计算必须被执行的次数。大多数编译器，包括GCC，向用户提供了一些对它们所使用的优化的控制，其中最简单的控制就是指定优化级别。 编译器必须很小心地对程序只使用安全的优化，也就是说对于程序可能遇到的所有可能的情况，在C语言标准提供的保证之下，优化后得到的程序和未优化的版本有一样的行为。 下面看个示例： void twiddle1(long *xp, long *yp) { *xp += *yp; *yp += *xp; } void twiddle2(long *xp, long *yp) { *xp += 2* *yp; } 乍一看，两个过程似乎有相同的行为。但当xp等于yp时，结果就不同了。这种两个指针可能指向同一个内存位置的情况称为内存别名使用(memory aliasing)。在只执行安全的优化中，编译器必须假设不同的指针可能会指向内存中同一个位置。 第二个妨碍优化的因素是函数调用。当被优化的函数有副作用时，很可能优化后的行为是错误的。 包含函数调用的代码可以用一个称为内联函数替换(inline substitution或inlining)的过程进行优化。此时，将函数调用替换为函数体。在某些情况下，最好能阻止编译器执行内联替换，如GDB。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:1:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.2 表示程序性能 我们引入度量标准每元素的周期数(Cycles Per Element, CPE)，作为一种表示程序新能并指导我们改进代码的方法。CPE这种度量标准帮助我们在更细节的级别上理解迭代程序的循环性能。这样的度量标准对执行重复计算的程序来说是很适当的。 处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用千兆赫兹(GHz)，即十亿周期每秒来表示。每个时钟周期的时间是时钟频率的倒数。从程序员的角度来看，用时钟周期来表示度量标准要比用纳秒或者皮秒来表示有帮助得多。用时钟周期来表示，度量值表示的是执行了多少条指令，而不是时钟运行得有多快。 图5-1中的函数用来计算向量的前置和(prefix sum)。 这样一个过程所需要的时间可以用一个常数加上一个与被处理元素个数成正比的因子来描述。图5-2是这两个函数需要的周期数关于n的取值范围图。 使用最小二乘拟合(least squares fit)，psum1和psum2的运行时间分别接近等式368+9.0n和368+6.0n。其中n的系数称为**每元素的周期数(CPE)**的有效值。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:2:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.3 程序示例 typedef struct { long len; data_t *data; } vec_rec, *vec_prt; data_t表示基本元素的数据类型。在测试中，我们度量代码对于整数(C语言的int和long)和浮点数(C语言的float和double)数据的性能，因此会使用类似如下的声明： typedef long data_t; 图5-4给出的是一些生成向量、访问向量元素以及确定向量长度的基本过程。 作为一个优化示例，图5-5中的代码，使用某种运算，讲一个向量中所有的元素合并成一个值。通过使用编译时常数IDENT和OP的不同定义，这段代码可以重编译成对数据执行不同的运算。 以下声明可对向量的元素求和： #define IDENT 0 #define OP + 以下声明可对向量的元素求乘积： #define IDENT 1 #define OP * 在我们的讲述中，我们会对这段代码进行一系列的变化，写出这个合并函数的不同版本。 作为一个起点，下表给出的是combine1的CPE度量值，它运行在我们的参考机上(一台Intel Core i7 Haswell处理器机器)。实验显示，32位整数和64位整数，性能相同。浮点数也一样。 从中可以看出，使用命令行选项\"-O1\"进行基本优化，都能显著提高程序性能。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:3:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.4 消除循环的低效率 识别循环中要执行多次但是计算结果不会改变的计算，将其移动到循环外面。 图5-6是combine2的代码。与combine1相比，性能提升了不少。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:4:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.5 减少过程调用 图5-9是combine3的代码。与combine2相比，内循环中没有函数调用。但性能与combine2相比基本没有提升。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:5:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.6 消除不必要的内存引用 图5-10是combine4的代码。与combine3相比，每次迭代的内存操作，从两次读和一次写，减少到只需要一次读。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:6:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.7 理解现代处理器 如果试图进一步提高性能，必须考虑利用处理器微体系结构的优化，也就是处理器用来执行指令的底层系统设计。 在代码级上，看上去似乎是一次执行一条指令，每条指令都包括从寄存器或内存取值，执行一个操作，并把结果存回到一个寄存器或内存位置。在实际的处理器中，是同时对多条指令求值的，这个现象称为指令级并行。 虽然现代微处理器的详细设计超出了本书讲授的范围，对这些微处理器的原则有一般性的了解就足够理解它们如何实现指令级并行。我们会发现两种下界描述了程序的最大性能。当一系列操作必须按照严格顺序执行时，就会遇到延迟界限(latency bound)，因为在下一条指令之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制程序性能。**吞吐量界限(throughput bound)**刻画了处理器功能单元的原始计算能力。这个界限时程序性能的终极限制。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:7:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.7.1 整体操作 图5-11是现代微处理器的一个非常简单化的示意图。 这些处理器在每个时钟周期可以执行多个操作，而且是乱序的。整个设计中有两个主要部分：指令控制单元(Instruction Control Unit, ICU)和执行单元(Execution Unit, EU)。前者负责从内存中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作；而后者执行这些操作。 ICU从**指令高速缓存(instruction cache，包含最近访问的指令)**中读取指令。通常ICU会在当前正在执行的指令很早之前取指，这样它才有足够的时间对指令译码，并把操作发送到EU。**指令控制(fetch control)**包括分支预测，以完成确定取哪些指令的任务。 **指令译码(instruction decode)**接收实际的程序指令，并把它们转换成一组基本操作。这种译码逻辑对指令进行分解，允许任务在一组专门的硬件单元之间进行分割。这些单元可以并行地执行多条指令的不同部分。 EU接收来自取指单元的操作。通常，每个时钟周期会接收多个操作。这些操作会被分派到一组**功能单元(functional units)**中，他们会执行实际的操作。这些功能单元用来处理不同类型的操作。 在ICU中，退役单元(retirement unit)记录正在进行的处理，并确保它遵守机器级程序的顺序语义。任何对程序寄存器的更新都只会在指令退役时才会发生，只有在处理器能够确信导致这条指令的所有分支都预测正确了，才会这样做。为了加速一条指令到另一条指令的结果的传送，许多此类信息时在执行单元之间交换的，即图中的操作结果(opration results)。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:7:1","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.7.2 功能单元的性能 图5-12是Intel Core i7 Haswell参考机的一些算术运算的性能： 表示运算性能的指标： 延迟(latency)：表示完成运算所需要的总时间 发射时间(issue time)：表示两个连续的同类型的运算之间需要的最小时钟周期数 容量(capacity)：表示能够执行该运算的功能单元的数量 可以看到，加法和乘法的发射时间都是1，意思是每个时钟周期，处理器都可以开始一条新的这样的运算。这种很短的发射时间是通过使用流水线(pipeline)实现的。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:7:2","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.7.3 处理器操作的抽象模型 这一小节介绍了一个分析在现代处理器上执行的机器级程序性能的工具–程序的数据流(data-flow)表示。这是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这些限制形成了图中的关键路径(critical path)，这是执行一组机器指令所需时钟周期数的一个下界。 1. 从机器级代码到数据流图 程序的数据流表示是非正式的。我们只是想用它来形象地描述程序中的数据相关是如何主宰程序的性能的。下面以combine4(图5-10)为例来描述数据流表示法。我们将注意力集中在循环执行的计算上，因为对于大向量来说，这是决定性能的主要因素。 我们考虑类型为double的数据、以乘法作为合并运算的情况。这个循环编译出的代码如下： 如图5-13，在我们假想的处理器设计中，指令译码器会把这4条指令扩展成为一系列的五步操作： 顶部方框表示循环开始时寄存器的值，底部的方框表示最后寄存器的值。 对于形成循环的代码片段，我们可以将访问到的寄存器分成四类： 只读：%rax 只写：本例中没有 局部：这些寄存器在循环内部被修改和使用，迭代与迭代之间不相关。本例中的条件码寄存器就是。 循环：对于循环来说，这些寄存器既作为源值，又作为目的，一次迭代中产生的值会在另一次迭代中使用。%rds和%xmm0就是。 正如我们会看到的，循环寄存器之间的操作链决定了限制性能的数据相关。 图5-14是对图5-13的进一步改进，目标是只给出影响程序执行时间的操作和数据相关。 图5-15给出了函数combine4内循环的n次迭代的数据流表示。 我们可以看到，程序又两条数据相关链，分别对应操作mul和add对程序值acc和data+i的修改。假设浮点乘法延迟为5个周期，整数加法延迟为1个周期，那么左边的链会成为关键路径。 2. 其他性能因素 对于整数加法的情况，我们对combine4的测试表明CPE为1.27，而不是根据图5-15中预测的CPE为1，测试值比预测值要慢。这说明，数据流表示中的关键路径提供的只是程序需要周期数的下界。还有其他一些因素会限制性能，包括可用的功能单元的数量和任何一步中功能单元之间能够传递数据值的数量。 总结一下combine4的性能分析：我们对程序操作的抽象数据流表示说明，combine4的关键路径长L * n是由对程序值acc的连续更新造成的，这条路径将CPE限制为最多L。 看上去，延迟界限是基本的限制，决定了我们的合并运算能够执行多快。接下来的任务是重新调整操作的结构，增强指令的并行性。我们想对程序做变换，使得唯一的限制变成吞吐量界限，得到接近于1.00的CPE。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:7:3","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.8 循环展开 循环展开是一种程序变换，通过增加每次迭计算的元素的数量，减少循环的迭代次数。 图5-16是合并代码使用“$2 \\times 1$循环展开”的版本。每次迭代，循环索引i加2，在一次迭代中对数据元素i和i+1使用合并运算。 按这个思想归纳为对一个循环按任意因子k进行展开，由此产生$k \\times 1$循环展开，它可以将性能改进到达到延迟界限，但不能超过。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:8:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.9 提高并行性 ","date":"2020-02-01","objectID":"/csapp_chapter5/:9:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.9.1 多个累积变量 图5-21展示了“$2 \\times 2$循环展开”。 归纳可得到$k \\times k$循环展开。当k足够大时，程序性能可达到吞吐量界限。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:10:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.9.2 重新结合变换 图5-26给出了combine7，它与combine5的区别在于内循环中元素合并的方式。 // combine5 acc = (acc OP data[i]) OP data[i+1]; // combine7 acc = acc OP (data[i] OP data[i+1]); 差别仅在于两个括号时如何放置的。我们称之为重新结合变换(reassociation transformatino)。 整数加法的性能没变化，整数乘法、浮点加法、浮点乘法的性能，则提升了一倍。 总的来说，重新结合变换能够减少计算中关键路径上操作的数量，通过更好地利用功能单元的流水线能力得到更好的性能。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:11:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.10 优化合并代码的结果小结 下表总结了对于标量(scalar)代码所获得的结果。使用多项优化技术，我们获得的CPE已经接近于0.50和1.00的吞吐量界限，只受限于功能单元的容量。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:12:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.11 一些限制因素 ","date":"2020-02-01","objectID":"/csapp_chapter5/:13:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.11.1 寄存器溢出 循环并行性的好处受汇编代码描述计算的能力限制。如果我们的并行度p超过了可用的寄存器数量，那么编译器会诉诸溢出(spilling)，将某些临时值存放到内存中，通常是在运行时堆栈上分配空间。 一旦编译器必须要诉诸寄存器溢出，那么维护多个累积变量的优势就很可能消失。幸运的是，x86-64有足够多的寄存器，大多数循环出现寄存器溢出之前就将达到吞吐量限制。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:13:1","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.11.2 分支预测和预测错误处罚 1. 不要过分关心可预测的分支 2. 书写适合用条件传送实现的代码 ","date":"2020-02-01","objectID":"/csapp_chapter5/:13:2","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.12 理解内存性能 到目前为止，我们写的所有代码和测试，只访问相对较少的内存。 所有的现代处理器都包含一个或多个**高速缓存(cache)**存储器，以对这样少量的存储器提供快速的访问。本节会进一步研究涉及加载(从内存读到寄存器)和存储(从寄存器写到内存)操作的程序的性能，只考虑所有的数据都存放在高速缓存中的情况。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:14:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.12.1 加载的性能 一个包含加载操作的程序的性能既依赖于流水线的能力，也依赖于加载单元的延迟。 要确定一台机器上加载造作的延迟，我们可以建立由一系列加载操作组成的一个计算，一条加载操作的结果决定下一条操作的地址。图5-31中计算链表长度的函数就是例子。测试表明函数list_len的CPE为4.00，我们认为这直接表明了加载操作的延迟。事实上，这个测试结果与文档中参考机的L1级cache的4周期访问时间是一致的，相关内容将在6.4节中讨论。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:14:1","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.12.2 存储的性能 存储操作的性能，尤其是与加载操作的相互关系，包括一些很细微的问题。 与记载操作一样，在大多数情况下，存储操作能够在完全流水线化的模式中工作，每个周期开始一条新的存储。存储操作并不影响任何的寄存器值，因此一系列存储操作不会产生数据相关。只有加载操作会受存储操作结果的影响，因为只有加载操作能从由存储操作写的那个位置读回值。 图5-33说明了加载和存储操作之间可能的相互影响。 经过测试，示例A的CPE1.3，示例B的CPE为7.3。示例B中存在写/读相关(write/read dependency)–一个内存读的结果依赖于一个最近的内存写，导致处理速度下降约6个时钟周期。 为了了解原因，我们必须更加仔细地看看加载和存储执行单元，如图5-34所示。 存储单元包含一个存储缓冲区(store buffer)，它包含已经被发射到存储单元而又还没完成的存储操作的地址和数据，这里的完成包括更新cache。提供这样一个缓冲区，使得一系列存储操作不必等待每个操作都更新cache就能够执行。当一个加载操作完成时，它必须检查存储缓冲区中的条目，看有没有地址相匹配。如果有地址相匹配，它就取出相应的数据条目作为加载操作的结果。 图5-35给出了这个循环代码的数据流表示。 图5-36说明了write_read内循环操作之间的数据相关。 图5-37说明的是内循环的多次迭代形成的数据相关。 对于示例A，有不同的源和目的地址，加载和存储操作可以独立进行，因此唯一的关键路径是由减少变量cnt形成的，这使得CPE等于1.0。对于示例B，源和目的地址相同，s_data和load指令之间的数据相关使得关键路径的形成包括了存储、加载、增加数据。顺序执行这三个操作一共需要7个时钟周期。 这两个例子说明，内存操作的实现包括许多细微之处。对于寄存器操作，在指令被译码成操作的时候，处理器就可以确定哪些指令会影响其他哪些指令。另一方面，对于内存操作，只有到计算出加载和存储的地址被计算出来以后，处理器才能确定哪些指令会影响其他的哪些。高效地处理内存操作对许多程序的性能来说至关重要。内存子系统使用了很多优化，例如当操作可以独立地进行时，就利用这种潜在的并行性。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:14:2","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.13 应用：性能提高技术 优化程序性能的基本策略： 高级设计。合适的算法和数据结构 基本编码原则。 消除连续的函数调用 消除不必要的内存引用 低级优化。结构化代码以利用硬件功能。 展开循环，降低开销 找到方法提高指令级并行 用功能性的风格重写条件操作，使得编译采用条件传送。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:15:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.14 确认和消除性能瓶颈 本节描述如何使用代码剖析程序(code prifiler)，优化大型程序。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:16:0","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.14.1 程序剖析 程序剖析(profiling)运行程序的一个版本，其中插入了工具代码，以确定程序的各个部分需要多少时间。 Unix系统提供了一个剖析程序GPROF。这个程序产生两种形式的信息。首先，它确定程序中每个函数花费了多少CPU时间。其次，它计算每个函数被调用的次数，以执行调用的函数来分类。 GPROF使用方法略。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:16:1","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"5.14.2 使用剖析程序来知道优化 略。 ","date":"2020-02-01","objectID":"/csapp_chapter5/:16:2","tags":["caspp"],"title":"[CSAPP]第五章 优化程序性能","uri":"/csapp_chapter5/"},{"categories":["读书笔记"],"content":"一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构(Instruction-Set Architecture, ISA)。 本章首先定义一个简单的指令集，作为我们处理器实现的运行示例，我们称之为“Y86-64”指令集。 作为设计处理器的第一步，我们给出一个基于顺序操作、功能正确但是有点不实用的Y86-64处理器。这个处理器每个时钟周期执行一条完整的Y86-64指令。 以这个顺序设计为基础，我们进行一系列的改造，创建一个流水线化的处理器(pipelined-processor)。这个处理器将每条指令的执行分解成五步，每个步骤由一个独立的硬件部分或阶段(stage)来处理。指令步经流水线的各个阶段，且每个时钟周期有一条新指令进入流水线。所以，处理器可以同时执行五条指令的不同阶段。为了使这个处理器保留Y86-64 ISA的顺序行为，就要求处理很多冒险或冲突(hazard)情况。冒险就是一条指令的位置或操作数依赖于其他仍在流水线中的指令。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:0:0","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.1 Y86-64指令集体系结构 定义一个指令集体系结构，包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:1:0","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.1.1 程序员可见的状态 Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分，这称为**程序员可见(programmer-visible)**状态。包括寄存器、条件码、程序计数器(PC)、内存，还有状态码Stat(表明程序执行的总体状态，它会指示是正常运行，还是出现了某种异常) ","date":"2019-12-29","objectID":"/csapp_chapter4/:1:1","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.1.2 Y86-64指令 ","date":"2019-12-29","objectID":"/csapp_chapter4/:1:2","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.1.3 指令编码 图4-2还给出了指令的字节级编码。每条指令需要1～10个字节不等。每条指令的第一个字节表明指令的类型，这个字节又分成两个部分，每个部分4位：高4位是code部分，低4位是function部分。 15个程序寄存器如下： 指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。这个性质保证了处理器可以无二义性地执行目标代码程序。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:1:3","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.1.4 Y86-64异常 对于Y86-64，当遇到异常的时候，我们就简单地让处理器停止执行指令。在更完整的设计中，处理器通常会调用一个异常处理程序(exception handler)，这个过程被指定用来处理遇到的某种类型的异常。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:1:4","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.1.5 Y86-64程序 long sum(long *start, long count) { long sum = 0; while (count) { sum += *start; start++; count--; } return sum; } 图4-6是这段程序的x86-64和Y86-64汇编代码。 图4-7是Y86-64汇编代码编写的一个完整的程序文件的例子。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:1:5","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.1.6 一些Y86-64指令的详情 pushq会把栈指针减8，并且将一个寄存器写入内存中。因此，当执行pushq %rsp指令时，处理器的行为时不确定的，因为要入栈的寄存器会被同一条指令修改。有两种不同的约定：(1)压入%rsp的原始值，(2)压入减去8的%rsp的值。x86-64和Y86-64都采用了(1)。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:1:6","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.2 逻辑设计和硬件控制语言HCL 要实现一个数字系统需要三个主要的组成部分：计算对位进行操作的函数的组合逻辑、存储位的存储器单元，以及控制存储器单元更新的时钟信号。 本节简要描述这些不同的组成部分，还将介绍HCL(Hardware Control Language，硬件控制语言)，用这种语言来描述不同处理器设计的逻辑控制。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:2:0","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.2.1 逻辑门 逻辑门是数字电路的基本计算单元。包括与、或、非。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:2:1","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.2.2 组合电路和HCL布尔表达式 将很多的逻辑门组合成一个网，就能构建计算块(computational block)，称为组合电路(combinational circuits)。 图4-10为检测位相等的组合电路，HCL函数为bool eq = (a \u0026\u0026 b) || (!a \u0026\u0026 !b) 图4-11是多路复用器(multiplexor，通常称为\"MUX\")，它根据输入控制信号的值，从一组不同的数据信号中选出一个。HCL表达式为bool out = (s \u0026\u0026 a) || (!s \u0026\u0026 b) ","date":"2019-12-29","objectID":"/csapp_chapter4/:2:2","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.2.3 字级的组合电路和HCL整数表达式 通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。通常，我们设计能够对数据字(word)进行操作的电路。 执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。 组合逻辑电路可以设计成在字级数据上执行许多不同类型的操作，具体的设计已经超出了我们讨论的范围。**算术/逻辑单元(ALU)**是一种很重要的组合电路。图4-15是它的一个抽象的图示。这个电路有三个输入：标号A和B的两个数据输入，以及一个控制输入。根据控制输入的设置，电路会对数据输入执行不同的算术或逻辑操作。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:2:3","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.2.4 集合关系 略 ","date":"2019-12-29","objectID":"/csapp_chapter4/:2:4","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.2.5 存储器和时钟 注意，csapp中文版将register file翻译成了寄存器文件，但更通用的翻译为寄存器堆，因此后文使用了寄存器堆这个翻译。 组合电路从本质上讲，不存储任何信息。相反，它们只是简单地响应输入信号，产生等于输入的某个函数的输出。为了产生时序电路(sequential circuit)，也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制的。时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两种存储设备： 时钟寄存器(clocked registers)(简称registers)：存储单个位或字。时钟信号控制寄存器加载输入值。 随机访问存储器(random access memories)(简称内存(memories))：存储多个字，用地址来选择该读或该写哪个字。ram的例子包括主存和寄存器堆。 在说到硬件和机器级编程时，“寄存器”这个词是由细微差别的。为了区分，我们会分别称之为“硬件寄存器”和“程序寄存器”。 图4-16说明了一个硬件寄存器是如何工作的。当每个时钟到达上升沿时，值才会从寄存器的输入传送到输出。我们的Y86-64处理器会用时钟寄存器保存程序计数器(PC)、条件码(CC)、程序状态(Stat)。 下图展示了一个典型的寄存器堆： 寄存器堆有两个读端口(A和B)，还有一个写端口(W)，这样一个多端口ram允许同时进行多个读和写操作。图中的寄存器堆，电路可以读取两个程序寄存器的值，同时更新第三个寄存器的状态。 处理器有一个ram用来存放程序数据，如下图： 这个内存有一个地址输入，一个用于写的数据输入，一个用于读的数据输出。read和write是控制信号。error是输出信号。 我们的处理器还包括另外一个只读存储器，用来读指令。在大多数实际系统中，这两个存储器被合并为一个具有双端口的存储器：一个用来读指令，另一个用来读或者写数据。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:2:5","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.3 Y86-64的顺序实现 现在已经有了实现Y86-64处理器所需要的部件。首先，我们描述一个称为SEQ(sequential)的处理器。每个时钟周期上，SEQ执行处理一条完整指令所需的所有步骤，因此时钟周期频率较低，效率低。我们的最终目标是实现一个高效的、流水线化的处理器。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:3:0","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.3.1 将处理组织成阶段 通常，处理一条指令包括很多操作： 取指(fetch)：从内存读取指令字节，地址为PC的值。 译码(decode)：从寄存器堆中读入最多两个操作数。 执行(execute)：ALU要么执行指令指明的操作，计算内存引用的有效地址，要么修改栈指针。 访存(memory)：将数据写入内存，或者从内存读出数据。 写回(write back)：做多可以写两个结果到寄存器堆。 更行PC(PC update)：将PC设置成下一条指令的地址。 下面我们使用图4-17中的代码来描述不同的Y86-64指令的处理。 图4-18给出了OPq(整数和逻辑运算)、rrmovq(寄存器-寄存器传送)和irmovq(立即数-寄存器传送)类型的指令的处理。 图4-19给出了内存读写指令rmmovq和mrmovq的处理。注意，内存操作的有效地址是通过计算偏移量与基址寄存器之和得到的。 图4-20给出了pushq和popq的处理。 图4-21给出了三类控制转移指令的处理：各种跳转、call和ret。 我们创建了一个统一的框架，能够处理所有不同类型的Y86-64指令。虽然指令的行为不大相同，但是我们可以将指令的处理组织成6个阶段。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:3:1","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.3.2 SEQ硬件结构 图4-22给出了一个能执行6个阶段的硬件结构的抽象表示。 图4-23更详细地给出了实现SEQ所需的硬件。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:3:2","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.3.3 SEQ的时序 原则：从不回读 处理器从来不需要为了完成一条指令的执行而去读由该指令更行了的状态。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:3:3","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.3.4 SEQ阶段的实现 本节会设计实现SEQ所需要的控制逻辑块的HCL描述。 略。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:3:4","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.4 流水线的通用原理 流水线化的一个重要特征就是提高了系统的吞吐量(throughput)，也就是单位时间内处理的指令数量，不过它也会轻微地增加延迟(latency)，也就是处理一条指令所需要的时间。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:4:0","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.4.1 计算流水线 在现代逻辑设计中，电路延迟以微微秒或皮秒(picosecond, “ps”)，也就是$10^{-12}$秒为单位来计算。 我们以每秒千兆条指令(GIPS)，也就是每秒十亿条指令，为单位来描述吞吐量。从头到尾执行一条指令所需要的时间称为延迟(latency)。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:4:1","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.4.2 流水线操作的详细说明 流水线阶段之间的指令转移是由时钟信号来控制的。每隔120ps，信号从0上升到1，开始下一组流水线阶段的计算。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:4:2","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.4.3 流水线的局限性 图4-33给出了一个理想的流水线化的系统，通过将计算划分成三个相互独立的阶段，来使得每个阶段需要的时间是原来逻辑的三分之一。不幸的是，会出现其他一下因素，降低流水线的效率。 1. 不一致的划分 如图4-36，仍然将计算划分成三个阶段，但每个阶段的延迟从50ps到150ps不等，通过所有阶段的延迟和仍然为300ps。不过运行时钟的速率是由最慢的阶段的延迟限制的。 通常，处理器中的某些硬件单元，如ALU和内存，是不能被划分成多个延迟较小的单元的，这就使得创建一组平衡的阶段非常困难。 2. 流水线过深，收益反而下降 图4-37说明了流水线技术的另一个局限性。将组合逻辑拆小后，寄存器更新引起的延迟将限制吞吐量的增长。 为了提高时钟频率，现代处理器采用了很深的流水线(15或更多的阶段)。电路设计者小心地设计流水线寄存器，使其延迟尽可能的小。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:4:3","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.4.4 带反馈的流水线系统 之前的例子，各个阶段的指令之间是完全独立的。但实际上，相邻指令之间很可能是相关的。 当我们将流水线技术引入Y86-64处理器时，必须正确处理反馈的影响，不能改变系统的行为。我们必须以某种方式来处理指令间的数据和控制依赖，以使得到的行为与ISA定义的模型相符。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:4:4","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.5 Y86-64的流水线设计 首先，对顺序的SEQ处理器做一点小的改动，将PC的计算挪到取指阶段。然后，在各个阶段之间加上流水线寄存器。再做一些修改，就能实现我们的目标–一个高效的、流水线化的实现Y86-64 ISA的处理器。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:5:0","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.5.1 SEQ+：重新安排计算阶段 为了更利于流水化，调整SEQ中五个阶段的顺序，使得更新PC阶段再一个时钟周期开始时执行，而不是结束时才执行。我们称这种修改过的设计为“SEQ+”。 图4-40给出了SEQ+硬件的一个详细的说明。 SEQ到SEQ+中对状态单元的改变是一种很通用的改进的例子，这种改进称为电路重定时(circuit retiming)。重定时改变了一个系统的状态表示，但是并不改变它的逻辑行为。通常用它来平衡一个流水线系统中各个阶段之间的延迟。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:5:1","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.5.2 插入流水线寄存器 我们要在SEQ+的各个阶段之间插入流水线寄存器，并对信号进行重新排列，得到PIPE-处理器，这里的“-”代表这个处理器和最终的处理器设计相比，性能要差一点。 PIPE-的抽象结构如图4-41。 流水线寄存器： F：保存程序计数器的预测值 D：位于取指和译码之间。 E：位于译码和执行之间。 M：位于执行和访存之间。保存罪行执行的指令的结果。还保存关于用于处理条件转移的分支条件和分支目标的信息。 W：位于访存和反馈路径之间，反馈路径将计算出来的值提供给寄存器堆写，而当完成ret指令时，它还要向PC选择逻辑提供返回地址。 图4-42是指令流通过流水线的示例。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:5:2","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.5.3 对信号进行重新排列和标号 为了唯一标识信号值，我们采用这样的命名机制：通过在信号名前面加上大写字母的流水线寄存器名字作为前缀，来唯一标识存储在流水线寄存器中的信号；通过在信号名前面加上小写字母的阶段名的第一个字母作为前缀，来唯一标识某个阶段内刚刚计算出来的信号。 信号M_stat和m_stat的区别： 在命名系统中，大写的前缀\"D\"、“E”、“M”、“W\"指的是流水线寄存器，所以M_stat指的是流水线寄存器M的状态码字段。小写的前缀\"f”、“d”、“e”、“m”、“w\"指的是流水线阶段，所以m_stat指的是在访存阶段中由控制逻辑产生出的信号状态。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:5:3","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.5.4 预测下一个PC 除了条件转移指令和ret以外，根据取指阶段中计算出的信息，我们能够确定下一条指令的地址。对于call和jump来说，下一条指令的地址是指令中的常数字valC，而对于其他指令来说就valP。因此，通过预测PC的下一个值，在大多数情况下，我们能够达到每个时钟周期发射一条新指令的目的。 猜测分支方向并根据猜测开始取指的技术称为分支预测(branch prediction)。我们使用简单的策略，即总是预测选择了条件分支，因而预测PC的新值为valC。 ret指令的新PC值几乎无法预测，因为返回地址是位于栈顶的字，其内容可以是任意的。我们只是简单地暂停处理新指令，知道ret指令通过回写阶段。 图4-41中的\"Select PC\"块类似于图4-40中\"PC\"块，它从三个值中选择一个作为指令内存的地址：预测的PC，对于到达流水线寄存器M的不选择分支的指令来说是valP的值（存储在寄存器M_valA中），或是当ret指令到达流水线寄存器W（存储在W_valM）时的返回地址的值。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:5:4","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.5.5 流水线冒险 将流水线技术引入一个带反馈的系统，当相邻指令间存在相关时会导致出现问题。这些相关有两种形式：1)数据相关(data dependencies)，下一条指令会用到这一条指令计算出的结果；2)控制相关(control dependencies)，一条指令要确定下一条指令的位置，如jmp、call、ret。这些相关可能会导致流水线产生计算错误，称为冒险(hazard)。冒险也分为两类：数据冒险(data hazard)和控制冒险(control hazard)。 当一条指令更新后面指令会读到的那些程序状态时，就有可能出现冒险。对于Y86-64来说，程序状态包括程序寄存器、程序计数器、内存、条件码寄存器、状态寄存器。通过分析，我们只需要处理寄存器数据冒险、控制冒险，以及确保能够正确处理异常，就能避免冒险。 1. 用暂停来避免数据冒险 暂停(stalling)是避免冒险的一种常用技术。暂停时，处理器会停止流水线中一条或多条指令，知道冒险条件不再满足。让一条指令停顿在译码阶段，知道产生它的源操作数的指令通过了回写阶段，这样我们的处理器就能避免数据冒险。 虽然这一机制容易实现，但性能并不好，严重降低了系统的吞吐量。 2. 用转发来避免数据冒险 将结果值直接从一个流水线阶段传到较早阶段的技术称为数据转发(data forwading)，有时称为旁路(bypassing)。它需要在基本的硬件结构中增加一些额外的数据连接和控制逻辑。 图4-52给出的是PIPE的结构，它是PIPE-的扩展，能通过转发处理数据冒险。 3. 加载/使用数据冒险 有一类数据冒险不能单纯用转发来解决，因为内存读在流水线中发生的比较晚。图4-53举例说明了加载/使用冒险(load/use hazard)，一条指令load，下一条指令use（0x028和0x032）。 如图4-54所示，可以将暂停和转发结合起来，避免加载/使用冒险。这个需要修改控制逻辑，但是可以使用现有的旁路路径。 这种用暂停来处理加载/使用冒险的方法称为加载互锁(load interlock)。加载互锁和转发技术结合起来足以处理所有可能类型的数据冒险。因为只有加载互锁会降低流水线的吞吐量，我们几乎可以实现每个时钟周期发射一条新指令的吞吐量目标。 4. 避免控制冒险 当处理器无法根据处于取指阶段的当前指令来确定下一条指令的地址时，就会出现控制冒险。如之前的讨论，控制冒险只会出现在ret指令和跳转指令，可以通过暂停和往流水线中插入气泡的技术来动态调整流水线的流程。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:5:5","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.5.6 异常处理 我们的指令集体系结构包括三种不同的内部产生的异常：1)halt指令；2)由非法指令和功能码组成的指令；3)取指或数据读写试图访问一个非法地址。 我们把导致异常的指令称为异常指令(exception instruction)。在一个更完整的设计中，处理器会继续调用异常处理程序(exception handler)，这是操作系统的一部分，超出了本书的讲述范围。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:5:6","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.5.7 PIPE各阶段的实现 HCL代码，略。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:5:7","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.5.8 流水线控制逻辑 现在准备创建流水线控制逻辑，完成我们的PIPE设计。这个逻辑必须处理下面4种控制情况，这些情况是其他机制不能处理的： 加载/使用冒险：在一条从内存中读出一个值的指令和一条使用该值的指令之间，流水线必须暂停一个周期。 处理ret：流水线必须暂停直到ret指令到达写回阶段。 预测错误的分支：在分支逻辑发现不应该选择分支之前，分支目标处的几条指令已经进入流水线了。必须取消这些指令，并从跳转指令后面的那条地址开始取指。 异常：当一条指令导致异常，我们想要禁止后面的指令更新程序员可见的状态，并且在异常指令到达写回阶段时，停止执行。 我们先浏览每种情况所期望的行为，然后再设计处理这些情况的控制逻辑。后面的部分略。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:5:8","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.5.9 性能分析 我们可以看到，所有需要流水线控制逻辑进行特殊处理的条件，都会导致流水线不能够实现每个时钟周期发射一条新指令的目标。我们可以通过确定往流水线中插入气泡的频率，来衡量这种效率的损失，因为气泡插入会导致未使用的流水线周期。一条ret指令会产生三个气泡，一个加载/使用冒险会产生一个，而一个预测错误的分支会产生两个。我们可以通过计算PIPE指令一条指令所需要的平均时钟周期数的估计值，来量化这些处罚对整体性能的影响，这种衡量方法称为CPI(Cycles Per Instruction，每指令周期数)。这种衡量值是流水线平均吞吐量的倒数，不过时间单位是时钟周期，而不是微微秒。这是一个设计体系结构效率的很有用的衡量标准。 如果忽略异常带来的性能损失，可以使用下面的方法来大致计算CPI： CPI = 1.0 + lp + mp + rp 其中，lp(load penalty)，mp(mispredicted branch penalty)，rp(return penalty)分别为那三种情况插入气泡的平均数。 对于CPI的计算，我们使用下面这组频率： 由此得到的CPI是1.27。 我们的目标是设计一个每个时钟周期发射一条指令的流水线，也就是CPI为1.0。为了进一步降低CPI，应该重点关注预测错误的分支。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:5:9","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.5.10 未完成的工作 多周期指令：如整数乘法和除法，浮点数运算。采用独立于主流水线的特殊硬件功能单元来处理这些复杂操作，能够得到更好的性能。 与存储系统的接口：涉及存储系统层次结构、缺页中断等。 现代处理器支持超标量(superscalar)操作，意味着它们通过并行地取指、译码和执行多条指令，可以实现小于1.0的CPI。最先进的设计使用了一种称为乱序(out-of-order)执行的技术来并行地执行多条指令，执行的顺序也可能完全不同于它们在程序中出现的顺序，但是保留了顺序ISA模型蕴含的整体行为。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:5:10","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"4.6 小结 略。 ","date":"2019-12-29","objectID":"/csapp_chapter4/:6:0","tags":["caspp"],"title":"[CSAPP]第四章 处理器体系结构","uri":"/csapp_chapter4/"},{"categories":["读书笔记"],"content":"3.1 历史观点 略 ","date":"2019-12-09","objectID":"/csapp_chapter3/:1:0","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.2 程序编码 假设一个C程序，有两个文件p1.c和p2.c，可以使用命令gcc -Og -o p p1.c p2.c来编译。编译选项-Og告诉编译器使用会产生符合原始C代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。因此我们使用-Og优化作为学习工具。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:2:0","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.2.1 机器级代码 对于机器级编程来说，有两种重要的抽象： 指令集体系结构/指令集架构(Instruction Set Architecture, ISA)，定义了机器级程序的格式和行为，定义了处理器状态、指令的格式，以及每条指令对状态的影响。 机器级程序使用的内存地址是虚拟地址。 一条机器指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现程序结构。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:2:1","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.2.2 代码示例 假设我们写了mstore.c： long mult2(long, long); void multstore(long x, long y, long *dest) { long t = mult2(x, y); *dest = t; } 运行命令gcc -Og -S mstore.c产生的汇编文件代码包含以下几行： multstore: pushq %rbx movq %rdx, %rbx call mult2 movq %rax, (%rbx) popq %rbx ret 上面代码中每个缩进去的行都对应与一条机器指令。 使用gcc -Og -c mstore.c会编译并汇编该代码，产生目标文件mstore.o，它是二进制格式的。1368字节的mstore.o中有一段14字节的序列，它的十六进制表示为： 53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3 这即是上面的汇编指令对应的目标代码。我们可以从中得到一个重要信息，即机器执行的程序只是一个字节序列，它是对一系列指令的编码。 要查看机器代码文件的内容，有一类称为反汇编器(disassambler)的程序非常有用。Linux中可以用objdump -d mstore.o得到如下结果： ","date":"2019-12-09","objectID":"/csapp_chapter3/:2:2","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.2.3 关于格式的注解 假设我们使用gcc -Og -S mstore.c生成文件mstore.s，内容如下： .file \"010-mstore.c\" .text .globl multstore .type multstore, @function multstore: pushq %rbx movq %rdx, %rbx call mult2 movq %rax, (%rbx) popq %rbx ret .size multstore, .-multstore .ident \"GCC: (Ubuntu 4.8.1-2ubuntu1~12.04) 4.8.1\" .section .note.GNU-stack,\"\",@progbits 所有以’.‘开头的行都是指导汇编器和链接器工作的伪指令，通常可忽略。 为了更清楚地说明汇编代码，我们使用下面这种格式： ","date":"2019-12-09","objectID":"/csapp_chapter3/:2:3","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.3 数据格式 由于是从16位体系结构扩展成32位的，Intel用术语“字(word)”表示16位数据类型。32位数称为“双字(double words)”，64位数称为“四字(quad words)”。 如图所示，大多是GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。后缀’l’用来表示双字，因为32位数倍看成是“长字(long words)”。虽然’l’也用来表示8字节双精度浮点数，但不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:3:0","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.4 访问信息 一个x86-64的CPU包含一组16个存储64位值的通用目的寄存器，用来存储整数数据和指针。它们的名字都以%r开头，后面的名字则是跟历史相关了。 名称解释： ax: accumulator register 累加器；也用来存放函数返回值 bx: base register 基地址寄存器，没啥特殊用途 cx: counter register 计数寄存器for loop dx: data register 数据寄存器 si: source index 源索引寄存器 di: destination index 目标索引寄存器 bp: base pointer 基址指针；指向栈底 sp: stack pointer 栈指针；指向栈顶 名称解释的参考资料：https://www.swansontec.com/sregisters.html 如图，指令可以对这16个寄存器的地位字节中存放的不同大小的数据进行操作。对于生成小于8个字节结果的指令，寄存器剩下的字节会怎样，有两条规则： 生成1字节和2字节数字的指令会保持剩下的字节不变 生成4字节数字的指令会把高位4字节置为0 ","date":"2019-12-09","objectID":"/csapp_chapter3/:4:0","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.4.1 操作数指示符 大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要使用的源数据值，以及存放结果的目的位置。x86-64支持的操作数格式如下： 源数据值可以以常数形式给出，或是从寄存器或内存中读出。 结果可以存放在寄存器或内存中。 因此，操作数可被分为三种类型： 立即数(immediate)：用来表示常数值。书写方式为$后面跟一个用标准C表示法表示的整数，如$101、$0x1F 寄存器(register)：某个寄存器的内容。我们用符号$r_a$表示任意寄存器$a$，用引用$R[r_a]$表示它的值。这是将寄存器集合看成一个数组$R$，用寄存器标识符作为索引。 内存引用：它会根据计算出来的地址访问某个内存位置。用符号$M_b[Addr]$表示对存储在内存中从地址$Addr$开始的$b$个字节的引用。为了简便，通常隐去$b$。 如上图，有多种不同的寻址模式，允许不同形式的内存引用。最常用的是图底部的$Imm(r_b, r_i, s)$：一个立即数偏移$Imm$，一个基址寄存器$r_b$，一个变址寄存器$r_i$和一个比例因子$s$(只能为1/2/4/8)。基址和变址寄存器都必须是64位寄存器。当引用数组和struct元素时，复杂的寻址模式是很有用的。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:4:1","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.4.2 数据传送指令 最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。 最简单形式的数据传送指令为MOV类，由四条指令组成：movb、movw、movl、movq，区别在于操作的数据大小不同。 源操作数指定的值是一个立即数，存储在寄存器或者内存中。目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。内存-\u003e内存可以通过两条指令完成，即内存-\u003e寄存器，寄存器-\u003e内存。 下图给出了五种可能的组合。记住，第一个参数是源操作数，第二个参数是目的操作数。 MOVZ和MOVS是两类将较小的源值复制到较大的目的时使用的数据移动指令，都是把数据从源复制到寄存器。MOVZ类中的指令把目的中剩余的字节填充为0，MOVS类中的指令通过符号扩展来填充，把源操作数的最高位进行复制。每条指令名字的最后两个字符都是大小指示符，分别指示源和目的的大小。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:4:2","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.4.3 数据传送示例 从中可以看出，C语言中的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:4:3","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.4.4 压入和弹出栈数据 在x86-64中，程序栈存放在内存中某个区域。栈向下增长，栈顶元素的地址是所有栈中元素地址中最低的。图中的栈是倒着画的，栈顶在图的底部。 将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。因此，指令pushq %rbp等价于下面两条指令： subq $8,%rsp // Decrement stack pointer movq %rbp,(%rsp) // Store %rbp on stack 区别在于机器代码中pushq指令编码为1个字节，而上面两条指令一共需要8个字节。 弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加8。因此，指令popq %rax等价于下面两条指令： movq (%rsp),%rax // Read %rax from stack addq $8,%rsp // Increment stack pointer %rsp指向的地址总是栈顶。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:4:4","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.5 算数和逻辑操作 这些操作被分成了四组：加载有效地址、一元操作、二元操作、位移。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:5:0","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.5.1 加载有效地址 加载有效地址(load effective address)指令leaq实际上是movq指令的变形，它将有效地址写入到目的操作数，可以为后面的内存引用产生指针。另外，它还可以简洁地描述普通的算数操作，例如假设寄存器%rdx的值为x，那么指令leaq 7(%rdx,%rdx,4),%rax将设置寄存器%rax的值为5x+7。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:5:1","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.5.2 一元和二元操作 一元操作类似于C语言中的++和--操作符。 二元操作类似于C语言中的赋值运算符，如x-=y。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:5:2","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.5.3 移位操作 先给出移位量，再给出要移位的数。 移位量是一个立即数，或者放在单字节寄存器%cl中。 左移指令有两个名字：SAL和SHL。二者效果一样，都是将右边填充0。 右移指令，SAR执行算术移位(填充符号位)，SHR执行逻辑移位(填充0)。 移位操作的目的操作数可以是一个寄存器或事一个内存地址。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:5:3","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.5.4 讨论 上面的大多数指令，既可以用于无符号运算，又可以用于补码运算。只有右移操作要求区分有符号和无符号数。这个特性是使得补码运算成为实现有符号整数运算的一种比较好的方法的原因之一。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:5:4","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.5.5 特殊的算术操作 两个64位有/无符号整数相乘的结果需要128位来表示。x86-64指令集对128位数的操作提供有限的支持。Intel把16字节的数称为八字(oct word)。 了解一下即可。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:5:5","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.6 控制 机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试结果来改变控制流或者数据流。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:6:0","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.6.1 条件码 除了整数寄存器，CPU还维护着一组单个位的条件码(conditon code)寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用的条件码有： CF: 进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。 ZF: 零标志。最近的操作得出的结果为0。 SF: 符号标志。最近的操作得到的结果为负数。 OF: 溢出标志。最近的操作导致一个补码溢出–正溢出或负溢出。 图3-10中，除了leaq外，其他指令都会设置条件码。 CMP和TEST指令只设置条件码而不改变任何其他寄存器。 CMP根据两个操作数之差来设置条件码。它除了只设置条件码而不更新目的寄存器之外，与SUB指令的行为是一样的。 TEST的行为与AND一样。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:6:1","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.6.2 访问条件码 条件码通常不会直接读取，常用的使用方式有三种： 可以根据条件码的某种组合，将一个字节设置为0或者1 可以条件跳转到程序的某个其他的部分 可以有条件地传送数据 我们将这一整类指令称为SET指令。它们之间的区别就在于它们考虑的条件码的组合是什么，这些指令名字的不同后缀指明了它们所考虑的条件码的组合。 一条SET指令的目的操作数是低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个字节设置成0或者1。为了得到一个32位或64位的结果，必须对高位清零。 一个计算C语言表达式a \u003c b的典型指令序列如下： 注：这一小节没看太明白，但感觉内容也不是很重要 ","date":"2019-12-09","objectID":"/csapp_chapter3/:6:2","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.6.3 跳转指令 正常执行的情况下，指令会按照它们出现的顺序一条一条地执行。跳转(jump)指令会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号(label)指明。 在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标(目的指令的地址)编码为跳转指令的一部分。 jmp指令是无条件跳转。它可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或内存地址读出的。 表中所示的其他跳转指令都是有条件的。这些指令的名字和跳转条件与SET指令的名字和设置条件是相匹配的。条件跳转只能是直接跳转。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:6:3","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.6.4 跳转指令的编码 在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是最常用的都是PC相对的(PC-relative)。也就是，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为1、2或4个字节。第二种编码方式是给出“绝对”地址，用4个字节直接指定目标，汇编器和链接器会选择适当的跳转目的编码。 右边反汇编器产生的注释中，第2行中跳转指令的跳转目标指明为0x8，第5行中跳转指令的跳转目标指明为0x5。再观察指令的字节编码，第一个跳转指令的目标编码为0x03(红框标注的)，把它加上0x5(即下一条指令的地址)就得到跳转目标地址0x8，也就是第4行指令的地址。 类似的，第二个跳转指令的目标为0xf8(红框标注的，十进制-8)，再加上0xd(即下一条指令的地址，十进制13)，我们得到0x5，即第3行指令的地址。 这些例子说明，当执行PC相对寻址时，程序计数器的值时跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。 下面是链接后的程序反汇编版本： 这些指令被重定位到不同的地址，但是第2行和第5行中跳转目标的编码并没有变。通过使用与PC相对的跳转目标编码，指令编码很简洁(只需要2字节)，而且目标代码可以不做改变就移到内存中不同的位置。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:6:4","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.6.5 用条件控制来实现条件分支 条件控制：conditional control 将条件表达式和语句从C语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。 C语言中的if-else语句的通用形式模板如下： if (test-expr) then-statement else else-statement 对于这种通用形式，汇编实现通常会使用下面这种形式（这里用C语法描述）： t = test-expr; if (!t) goto false; then-statement goto done; false: else-statement; done: 也就是，汇编为then-statement和else-statement产生各自的代码块。它会插入条件和无条件分支，以保证能执行正确的代码块。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:6:5","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.6.6 用条件传送来实现条件分支 条件传送：conditional move 这种方法会计算一个条件操作的两种结果（即计算then-statement和else-statement），然后再根据条件是否满足，从中选取一个。只有在一些受限制的情况下，这种策略才可行。一旦可行，就可以用一条简单的conditional move指令来实现它，这个指令更符合现代处理器的性能特性。 为什么基于conditional move的代码会比基于conditional control的代码性能要好？因为处理器使用pipelining来获得高性能，这要求能够事先确定要执行的指令序列，这样才能保证流水线中充满了待执行的指令。当机器遇到条件跳转（分支）时，只有当分支条件求值完成之后，才能决定分支往哪边走。如果处理器预测错了，那么处理器将丢掉该跳转指令后所有指令已经做了的工作，然后再从正确的位置重新填充流水线，这样性能就下降了。 下图列举了一些条件conditional control指令。它们都有两个操作数，结果取决于条件码的值。 考虑下面的条件表达式和赋值的通用形式： v = test-expr ? then-expr : else-expr; 用conditional control transfer的标准方法来编译这个表达式，会得到如下形式： if (!test-expr) goto false; v = then-expr; goto done; false: v = else-expr; done: 基于conditional control的代码，会对then-expr和else-expr都求值，最终值的选择基于对test-expr的求值。可以用下面的抽象代码描述： v = then-expr ve = else-expr t = test-expr if (!t) v = ve 这个序列中的最后一条语句是用conditional move实现的–只有当测试条件t满足时，vt的值才会被复制到v中。 不是所有的条件表达式都可以用conditional move来编译。因为要对then-expr和else-expr都求值，所以如果其中任意一个表达式可能产生错误条件或者副作用，就会导致非法的行为。3.6.5中的例子就是这种情况。 使用conditional move也不总是会提高代码的效率。比如then-expr或else-expr的求值计算量很大，那么当对应的条件不满足时，就白计算了。 总的来说，条件数据传送提供了一种用条件控制转移来实现条件操作的替代策略。它们只能用于非常受限制的情况，但这些情况还是相当常见的，并且与现代处理器的运行方式更契合。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:6:6","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.6.7 循环 C语言提供了多种循环结构，即do-while、while和for。 do-while 通用形式： do body-statement while (test-expr); 这种通用形式可以被翻译成： loop: body-statement t = test-expr; if (t) goto loop; while 通用形式： while (test-expr) body-statement 第一种翻译方法，我们称之为跳转到中间(jump into middle)。它执行一个无条件跳转跳到循环结尾处的测试，以此来执行初始的测试。 goto test; loop: body-statement test: t = test-expr if (t) goto loop; 第一种翻译方法，我们称之为guarded-do。首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为do-while循环。 t = test-expr if (!t) goto done; do body-statement while (test-expr); done: 还可以把它翻译成goto代码： t = test-expr if (!t) goto done; loop: body-statement t = test-expr if (t) goto loop; done: 利用这种实现策略，编译器常常可以优化初始的测试，例如认为测试条件总是满足。 for 通用形式： for (init-expr; test-expr; update-expr) body-statement 大部分情况下，都可以等价为使用while循环： init-expr while (test-expr) { body-statement update-expr } GCC为for循环产生的代码是while循环的两种翻译之一，这取决于优化的等级。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:6:7","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.6.8 switch语句 switch语句可以根据一个整数索引值进行多重分支(multiway branching)。在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了C代码的可读性，而且通过使用**跳转表(jump table)**这种数据结构使得实现更加高效。跳转表是一个数组，表项i是一个代码段的地址，这个代码段实现当开关索引值等于i时程序应该采取的动作。当开关情况数量较多，并且值的范围跨度较小时，GCC会使用跳转表。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:6:8","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.7 过程 过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后可以在程序中不同的地方调用这个函数。 假设过程P调用过程Q，Q执行后返回到P。这些动作包括以下一个或多个机制： 传递控制：在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始位置，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。 传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。 分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:7:0","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.7.1 运行时栈 程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。 当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧(stack frame) 如图所示，我们把Q返回时的返回地址当做P的栈帧的一部分，因为它存放的是与P相关的状态。 大多数过程的栈帧都是定长的，在过程的开始就分配好了。变长的栈帧在3.10.5节中讨论。通过寄存器，过程P可以传递最多6个整数值，但是如果Q需要更多的参数，P可以在调用Q之前在自己的栈帧里存储好这些参数。 实际上，许多函数甚至根本不需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数（有时称之为叶子过程，此时把过程调用看做树结构）时，就可以这样处理。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:7:1","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.7.2 转移控制 将控制从函数P转移到函数Q，只需要简单地把程序计数器(PC)设置为Q的代码的起始位置。不过，当稍后从Q返回的时候，处理器必须记录好它需要继续执行的P的代码位置。在x86-64机器中，这个信息是用指令call Q调用过程Q来记录的。该指令会把地址A压入P的栈中，并将PC设置为Q的起始位置。压入的地址A被称为返回地址(return address)，是紧跟在call指令后面的那条指令的地址。对应的指令ret会从栈中弹出地址A，并把PC设置为A。 可以看到，这种把返回地址压入栈的简单机制能够让函数在稍后返回到过程中正确的点。C语言标准的调用/返回机制刚好与栈提供的后进先出的内存管理方法吻合。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:7:2","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.7.3 数据传送 在x86-64中，大部分过程的间的数据传送是通过寄存器实现的，可以通过寄存器最多传递6个整形(例如整数和指针)参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小。 如果一个函数有大于6个整形参数，超出6个的部分就要通过栈来传递。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:7:3","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.7.4 栈上的局部存储 以下情况，局部数据必须放在内存中： 寄存器不足够存放所有的本地数据 对一个局部变量使用地址运算符\u0026，因此必须能够为它产生一个地址 某些局部变量是array或struct，所以必须能够通过array or structure references被访问到 一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为local variables，如上面的图3-25所示。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:7:4","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.7.5 寄存器中的局部存储空间 寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程调用另一个过程时，被调用者不会覆盖调用者稍后会使用的寄存器组。因此，x86-64采用了一组统一的寄存器使用惯例，所有的过程都必须遵守。 根据惯例，寄存器%rbx、%rbp和%r12~%r15被划分为callee-saved registers。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q如果要使用这些寄存器，那么必须把原始值压入栈中，返回前再从栈中弹出旧值。这些旧值会在栈帧中创建标号为\"saved registers\"的一部分，如图3-25所示。 其他所有的寄存器（除了栈指针%rsp）都被分类为caller-saved registers。过程P在某个此类寄存器中有局部数据，然后调用过程Q。因为Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是P的责任。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:7:5","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.7.6 递归过程 递归调用一个函数本身与调用其他函数是一样的。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:7:6","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.8 数组分配和访问 ","date":"2019-12-09","objectID":"/csapp_chapter3/:8:0","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.8.1 基本原则 对于数据类型T和整形常数N，声明如下：$T A[N];$ 起始位置表示为$x_A$。这个声明有两个效果：首先，它在内存中分配一个$L * N$字节的连续区域，这里$L$是数据类型$T$的大小(单位为字节)。其次，它引入了标识符$A$，可以用$A$来作为指向数组开头的指针，这个指针的值就是$x_A$ ","date":"2019-12-09","objectID":"/csapp_chapter3/:8:1","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.8.2 指针运算 C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。 单操作数操作符’\u0026‘和’*‘可以产生指针和间接引用指针。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:8:2","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.8.3 嵌套的数组 要访问多维数组的元素，编译器会以数组起始为基地址，(可能需要经过伸缩的)偏移量为索引，产生计算期望的元素的偏移量，然后使用某种MOV命令。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:8:3","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.8.4 定长数组 C语言编译器能够优化定长多维数组上的操作代码。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:8:4","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.8.5 变长数组 ISO C99引入了变长数组，允许数组的维度是表达式，在数组被分配的时候才计算出来。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:8:5","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.9 异质的数据结构 struct和union ","date":"2019-12-09","objectID":"/csapp_chapter3/:9:0","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.9.1 结构 struct的所有组成部分都存放在内存中一段连续的区域内，而指向struct的指针就是struct第一个字节的地址。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:9:1","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.9.2 联合 union提供了一种方式，能够规避C语言的类型系统，允许以多种类型来引用一个对象。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:9:2","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.9.3 数据对齐 许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值(通常是2、4或8)的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:9:3","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.10 在机器级程序中将控制与数据结合起来 ","date":"2019-12-09","objectID":"/csapp_chapter3/:10:0","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.10.1 理解指针 我们重点介绍一些指针和它们映射到机器代码的关键原则： 每个指针都对应一个类型 每个指针都有一个值 指针用’\u0026‘运算符创建 ’*‘操作符用于间接引用指针 数组与指针紧密联系 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值 指针也可以指向函数 ","date":"2019-12-09","objectID":"/csapp_chapter3/:10:1","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.10.2 应用：使用GDB调试器 略 ","date":"2019-12-09","objectID":"/csapp_chapter3/:10:2","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.10.3 内存越界引用和缓冲区溢出 我们已经看到，C对于数组引用不进行任何边界检查，而且局部变量和状态信息都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破快存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令时，就会出现很严重的错误。 一种特别常见的状态破坏称为缓冲区溢出(buffer overflow)。通常，在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。 缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码(exploit code)，另外，还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，执行ret指令的效果就是跳转到攻击代码。 在一种攻击形式中，攻击代码会使用系统调用启动一个shell程序，给攻击者提供一组操作系统函数。在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行ret指令，(表面上)正常返回到调用者。蠕虫(worm)病毒就使用者这种攻击方式。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:10:3","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.10.4 对抗缓冲区溢出攻击 1. 栈随机化 为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段攻击代码的指针，这个指针也是攻击字符串中的一部分。产生这个指针需要知道这个字符串放置的栈位置。老系统中的程序的栈地址非常容易预测，栈的位置相当固定。 **栈随机化(Stack Randomization)**的思想使得栈的位置在程序每次运行时都有变化。 在Linux中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术称为地址空间布局随机化(Address-Space Layout Randomization)，或者简称ASLR。采用ASLR，每次运行程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域。 2. 栈破坏检测 最近的GCC版本在产生的代码中加入了一种栈保护者(stack protector)机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀(canary)值，它也称为哨兵值(guard value)，是在程序每次运行时随机产生的。在回复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作改变了。如果是的，那么程序异常中止。 栈保护很好地防止了缓冲区溢出攻击破坏存储在程序栈上的状态。它只会带来很小的性能损失。 3. 限制可执行代码区域 最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:10:4","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.10.5 支持变长栈帧 有些函数，需要的局部存储是变长的，比如调用alloca时。 为了管理变长栈帧，x86-64代码使用寄存器%rbp作为帧指针(frame pointer，又称为base pointer)。当使用%rbp时，栈帧的组织结构如下图。可以看到，代码必须把%rbp之前的值保存到栈中，因为它是一个callee-saved register。然后在整个函数的执行过程中，都是用%rbp指向那个时刻栈的位置，然后用固定长度的局部变量(比如i)相对于%rbp的偏移量来引用它们。 在函数的结尾，leave指令帧指针恢复到它之前的值(第20行)。这条指令不需要参数，等价于执行下面两条指令： movq %rbp, %rsp # set stack pointer to beginning of frame popq %rbp # restore saved %rbp and set stack ptr to end of the caller's frame ","date":"2019-12-09","objectID":"/csapp_chapter3/:10:5","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.11 浮点代码 简要回顾历史会对理解x86-64浮点体系结构有所帮助。1997年出现了Pentium/MMX，Intel和AMD都引入了持续数代的用于支持图形和图像处理的媒体(media)指令。这些指令本意是允许多个操作以并行模式执行，称为single instruction, multiple data，或SIMD(读作sim-dee)。在这种模式中，可以对多个不同的数据并行执行同一个操作。 名字的演化过程：MMX -\u003e SSE(Streaming SIMD Extention) -\u003e AVX(Advanced Vector Extention) 我们的讲述基于AVX2。 AVX浮点体系结构允许数据存储在16个YMM寄存器中，它们的名字为%ymm0~%ymm15。每个YMM寄存器都是256位。当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低32位(float)或64位(double)。汇编代码用寄存器的SSE XMM寄存器名字%xmm0~%xmm15来引用它们，每个XMM寄存器都是对应的YMM寄存器的低128位。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:11:0","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.11.1 浮点传送和转换操作 下图给出了一组在内存和XMM寄存器之间，以及从一个XMM寄存器到另一个XMM寄存器，不做任何转换地传送浮点数的指令。引用内存的指令是标量(scalar)指令，意味着它们只对单个而不是一组封装好的数据值进行操作。 其他指令，包括浮点数和整数类型之间的转化，不同浮点格式之间的转换，这里就不详细说了。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:11:1","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.11.2 过程中的浮点代码 在x86-64中，XMM寄存器用来向函数传递浮点参数，以及从函数返回浮点值。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:11:2","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.11.3 浮点运算操作 每个指令有一个或两个源操作数，一个目的操作数：加、减、乘、除、最大、最小、平方根。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:11:3","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.11.4 定义和使用浮点常数 和整数运算操作不同，AVX浮点操作不能以立即数作为操作数。编译器必须为所有的浮点常量值分配和初始化存储空间，然后代码再把这些值从内存读取寄存器来使用。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:11:4","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.11.5 在浮点代码中使用位级操作 位级异或(EXCLUSIVE-OR)，位级与(AND)： ","date":"2019-12-09","objectID":"/csapp_chapter3/:11:5","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.11.6 浮点比较操作 它们类似于CMP指令，比较操作数S1和S2，并且设置条件码来指示它们的相对值。 浮点比较指令会设置三个条件码：零标志位ZF、进位标志位CF、奇偶标志位PF(操作数中出现NaN时使用)。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:11:6","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"3.11.7 对浮点代码的观察结论 用AVX2为浮点数上的操作产生的机器代码风格类似于为整数上的操作产生的代码风格。它们都使用一组寄存器来保存和操作数据值，也都使用这些寄存器来传递函数参数。 AVX2还有能力在封装好的数据上执行并行操作，使计算执行地更快。 ","date":"2019-12-09","objectID":"/csapp_chapter3/:11:7","tags":["caspp"],"title":"[CSAPP]第三章 程序的机器级表示","uri":"/csapp_chapter3/"},{"categories":["读书笔记"],"content":"2.1 信息存储 ","date":"2019-12-05","objectID":"/csapp_chapter2/:1:0","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.1.1 十六进制表示法 ","date":"2019-12-05","objectID":"/csapp_chapter2/:1:1","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.1.2 字数据大小 ","date":"2019-12-05","objectID":"/csapp_chapter2/:1:2","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.1.3 寻址和字节顺序 ","date":"2019-12-05","objectID":"/csapp_chapter2/:1:3","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.1.4 表示字符串 ","date":"2019-12-05","objectID":"/csapp_chapter2/:1:4","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.1.5 表示代码 ","date":"2019-12-05","objectID":"/csapp_chapter2/:1:5","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.1.6 布尔代数简介 ","date":"2019-12-05","objectID":"/csapp_chapter2/:1:6","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.1.7 C语言中的位级运算 ","date":"2019-12-05","objectID":"/csapp_chapter2/:1:7","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.1.8 C语言中的逻辑运算 ","date":"2019-12-05","objectID":"/csapp_chapter2/:1:8","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.1.9 C语言中的移位运算 ","date":"2019-12-05","objectID":"/csapp_chapter2/:1:9","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.2 整数表示 ","date":"2019-12-05","objectID":"/csapp_chapter2/:2:0","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.2.1 整数数据类型 ","date":"2019-12-05","objectID":"/csapp_chapter2/:2:1","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.2.2 无符号数的编码 ","date":"2019-12-05","objectID":"/csapp_chapter2/:2:2","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.2.3 补码编码 ","date":"2019-12-05","objectID":"/csapp_chapter2/:2:3","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.2.4 有符号数和无符号数之间的转换 ","date":"2019-12-05","objectID":"/csapp_chapter2/:2:4","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.2.5 C语言中的有符号数和无符号数 ","date":"2019-12-05","objectID":"/csapp_chapter2/:2:5","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.2.6 扩展一个数字的位表示 ","date":"2019-12-05","objectID":"/csapp_chapter2/:2:6","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.2.7 截断数字 ","date":"2019-12-05","objectID":"/csapp_chapter2/:2:7","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.2.8 关于有符号数与无符号数的建议 ","date":"2019-12-05","objectID":"/csapp_chapter2/:2:8","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.3 整数运算 ","date":"2019-12-05","objectID":"/csapp_chapter2/:3:0","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.3.1 无符号加法 ","date":"2019-12-05","objectID":"/csapp_chapter2/:3:1","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.3.2 补码加法 ","date":"2019-12-05","objectID":"/csapp_chapter2/:3:2","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.3.3 补码的非 ","date":"2019-12-05","objectID":"/csapp_chapter2/:3:3","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.3.4 无符号乘法 ","date":"2019-12-05","objectID":"/csapp_chapter2/:3:4","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.3.5 补码乘法 ","date":"2019-12-05","objectID":"/csapp_chapter2/:3:5","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.3.6 乘以常数 ","date":"2019-12-05","objectID":"/csapp_chapter2/:3:6","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.3.7 除以2的幂 ","date":"2019-12-05","objectID":"/csapp_chapter2/:3:7","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.3.8 关于整数运算的最后思考 ","date":"2019-12-05","objectID":"/csapp_chapter2/:3:8","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.4 浮点数 ","date":"2019-12-05","objectID":"/csapp_chapter2/:4:0","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.4.1 二进制小数 ","date":"2019-12-05","objectID":"/csapp_chapter2/:4:1","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.4.2 IEEE浮点表示 IEEE浮点标准用 $V=(-1)^s \\times M \\times 2^E$ 的形式来表示一个数： 符号(sign) $s$ 决定这个数是正数还是负数 尾数(significand) $M$ 是一个二进制小数，它的范围是 $1$ 到 $2 - \\varepsilon$ 或者是 $0$ 到 $1 - \\varepsilon$ 阶码(exponent) $E$ 的作用是对浮点数加权，这个权重是2的$E$次幂(可能是负数) 将浮点数的位表示划分为三个字段，分别对这些值进行编码： 一个单独的符号位 $s$ 直接编码符号 $s$ $k$ 位的阶码字段 $exp={e_{k-1}}{···}{e_1}{e_0}$ 编码阶码 $E$ $n$ 位小数字段 $frag={f_{n-1}}{···}{f_1}{f_0}$ 编码尾数 $M$ ，但是编码出来的值也依赖于阶码字段的值是否等于0 bits len s exp frag 32 bits 1 8 23 64 bits 1 11 52 给定位表示，根据exp的值，被编码的值可以分成三种不同的情况(最后一种情况有两个变种) 情况1：规格化的值 当exp的位模式不全为0且不全为1时，这是最普遍的情况。 阶码被解释为以**偏置(biased)形式表示的有符号整数，即 $E=e-Bias$ ，其中 $e$ 是具有 ${e_{k-1}}{···}{e_1}{e_0}$ 位表示的无符号整数，而 $Bias$ 是一个等于 $2^{k-1} - 1$ (单精度是127，双精度是1023)的偏置值。由此产生的取值范围，对于单精度float是-126~+127，对于双精度double是-1022~+1023。 小数字段frac被解释为描述小数值 $f$ ，其中 $0 \\leqslant f \u003c 1$ ，其二进制表示为 $0.{f_{n-1}···{f_1}{f_0}}$ ，也就是二进制小数点在最高有效位的左边。尾数定义为 $M=1+f$ ，这种方式也叫做隐含的以1开头的(implied leading 1)**表示，因为我们可以把 $M$ 看成一个二进制表达式为 $1.{f_{n-1}···{f_1}{f_0}}$ 的数字。我们可以通过调整 $E$ 来使得尾数 $M$ 保持在 $1 \\leqslant M \u003c 2$ 范围之中(假设没有溢出)。既然第一位总是1，那么我们就不需要显示地表示它，因此我们也获得了一个额外的精度位。 情况2：非规格化的数 阶码域全为0。阶码值是 $E=1-Bias$ ，尾数值是 $M=f$ 非规格化数有两个用途。 首先是表示0。符号位是0，其他位全是0，值为+0.0；符号位是1，其他位全是0，值为-0.0。 其次，可用于表示那些非常接近0.0的数。它们提供了一种属性，称为逐渐溢出(gradual underflow)，其中，可能的数值分布均匀地接近于0.0。 情况3：特殊值 阶码域全为1。 当小数域全为0时，得到的值表示无穷。当 $s=0$ 时是 $+\\infty$，当 $s=1$ 时是 $-\\infty$。 当小数域为非零时，结果值被称为 $NaN$ ，即\"not a number\"的缩写。 ","date":"2019-12-05","objectID":"/csapp_chapter2/:4:2","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.4.3 数字示例 上图是8位浮点格式的实例。其中4个阶码位，3个小数位。偏置量是 $2^{4-1}-1=7$ 可以观察到最大非规格化数 $\\frac{7}{512}$ 和最小规格化数 $\\frac{8}{512}$ 之间的平滑转变。这种平滑性归功于我们对非规格化数的 $E$ 的定义。 这种表示有一种有趣的属性。加入我们将途中的值的位表达式解释为无符号整数，它们就是按生序排列的，就像它们表示的浮点数一样。这是IEEE特意设计的，可以让浮点数使用整数排序函数来进行排序。当处理负数时，要注意开头的1，并且它们是按降序出现的。 下图展示了一些重要的单精度和双精度的非负浮点数的表示和数字值。 ","date":"2019-12-05","objectID":"/csapp_chapter2/:4:3","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.4.4 舍入 因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算。因此，对于值 $x$ ，我们一般想用一种系统的方法，能够找到“最接近的”匹配值 $x^{’}$ ，它可以用期望的浮点形式表示出来。这就是**舍入(rouding)**运算的任务。一个关键问题是在两个可能值的中间确定舍入方向。 IEEE浮点格式定义了四种不同的舍入方式。默认的方法是找到最接近的匹配，其他三种可用于计算上下界。 向偶数舍入(round-to-even)，也被称为向最接近的值舍入(round-to-nearest)，是默认的方式，试图找到一个最接近的匹配值。它将数字向上或者向下舍入，使得结果的最低有效位数字是偶数。 向偶数舍入法能够运用到二进制小数上。我们将最低有效位的值0认为是偶数，值1认为是奇数。 ","date":"2019-12-05","objectID":"/csapp_chapter2/:4:4","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.4.5 浮点运算 把浮点值 $x$ 和 $y$ 看成实数，而某个运算 $\\bigodot$ 定义在实数上，计算将产生 $x \\bigodot y$ ，这是对实际运算的精确结果进行舍入后的结果。 浮点加法不具有结合性。另一方面，浮点加法满足了单调性属性。 ","date":"2019-12-05","objectID":"/csapp_chapter2/:4:5","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"2.4.6 C语言中的浮点数 ","date":"2019-12-05","objectID":"/csapp_chapter2/:4:6","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"参考资料 What Every Computer Scientist Should Know About Floating-Point Arithmetic ","date":"2019-12-05","objectID":"/csapp_chapter2/:5:0","tags":["caspp"],"title":"[CSAPP]第二章 信息的表示和处理","uri":"/csapp_chapter2/"},{"categories":["读书笔记"],"content":"示例程序hello.c #include \u003cstdio.h\u003e int main() { printf(\"hello, world\\n\"); return 0; } ","date":"2019-12-02","objectID":"/csapp_chapter1/:0:0","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.1 信息就是bits+context hello.c程序是以字节序列的方式存储在文件中的。 系统中的所有信息–包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。 ","date":"2019-12-02","objectID":"/csapp_chapter1/:1:0","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.2 程序被其他程序翻译成不同的格式 预处理器、编译器、汇编器、链接器一起构成了编译系统(compilation system)： 预处理器：根据已字符#开头的命令，修改原始的C程序，结果得到另一个C程序，通常是以.i作为文件扩展名。 编译器：将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编文件程序。 汇编器：将hello.s翻译成机器语言指令，将这些指令到爆成为一种叫做可重定位目标文件的格式，并将结果保存在目标文件hello.o(二进制文件)中。 链接器：printf函数存在与一个名为printf.o的单独的预编译好了的目标文件中，这个文件必须以某种方式合并到hello.o中。链接器就负责这种合并。结果就得到hello这个可执行目标文件文件，可以被加载到内存中，由系统执行。 ","date":"2019-12-02","objectID":"/csapp_chapter1/:2:0","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.3 了解编译系统如何工作是大有益处的 优化程序性能 理解链接时出现的错误 避免安全漏洞 ","date":"2019-12-02","objectID":"/csapp_chapter1/:3:0","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.4 处理器读并解释存储在内存中的指令 ","date":"2019-12-02","objectID":"/csapp_chapter1/:4:0","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.4.1 系统的硬件组成 总线 贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字(word)。字中的字节数(即字长)是一个基本的系统参数，现代系统大多为4个字节(32位)或8个字节(64位)。 I/O设备 每个I/O设备都通过一个控制器或适配器与I/O总线相连。控制器与适配器之间的区别主要在于它们的封装方式。控制器是I/O设备本身或者系统的主印制电路板(主板)上的芯片组。适配器则是一块插在主板插槽上的卡。 主存 主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组**动态随机存取存储器(DRAM)**芯片组成的。 处理器 中央处理单元(CPU)，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或寄存器)，称为程序计数器(PC)。在任何时刻，PC都指向主存中的某条机器语言指令(即含有该条指令的地址)。 处理器一直不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。 寄存器文件是一个小的存储设备，由一些单个字长的寄存器构成，每个寄存器都有唯一的名字。 ALU计算新的数据和地址值。 我们将处理器的指令集架构和处理器的微体系结构区分开来： 指令集架构描述的是每条机器代码指令的效果 微体系结构描述的是处理器实际上如何实现的 ","date":"2019-12-02","objectID":"/csapp_chapter1/:4:1","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.4.2 运行hello程序 当我们在键盘上输入字符串./hello后， shell程序将字符逐一读入寄存器，再把它放到内存中。 敲回车后，shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到内存汇总。利用直接存储器存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存。 然后处理器执行hello程序中的main程序中的机器语言指令。这些指令将\"hello, world\\n\"字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。 ","date":"2019-12-02","objectID":"/csapp_chapter1/:4:2","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.5 高速缓存至关重要 处理器和主存之间的速度差距在持续扩大。针对这一现象，系统设计者采用了更小更快的存储设备，称为高速缓存存储器(cache memory)，作为暂时的集结区域，存放处理器机器可能会需要的信息。 L1、L2、L3高速缓存是用一种叫做静态随机访问存储器(SRAM)的硬件技术实现的。 ","date":"2019-12-02","objectID":"/csapp_chapter1/:5:0","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.6 存储设备形成层次结构 ","date":"2019-12-02","objectID":"/csapp_chapter1/:6:0","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.7 操作系统管理硬件 操作系统有两个基本功能： 防止硬件被失控的应用程序滥用 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。 文件是对I/O设备的抽象；虚拟内存是对主存和磁盘I/O设备的抽象表示；进程是对处理器、主存和I/O设备的抽象表示。 ","date":"2019-12-02","objectID":"/csapp_chapter1/:7:0","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.8 系统间利用网络通信 略 ","date":"2019-12-02","objectID":"/csapp_chapter1/:8:0","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.9 重要主题 ","date":"2019-12-02","objectID":"/csapp_chapter1/:9:0","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.9.1 Amdahl定律 当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。想要显著加速整个系统，必须提升全系统中相当大的部分的速度。 ","date":"2019-12-02","objectID":"/csapp_chapter1/:9:1","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.9.2 并发和并行 多核处理器和超线程的出现，让线程级并发得到极大提升。 在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。早期的处理器心需要多个时钟周期来处理一条指令。现代处理器可以保持每个时钟周期2～4条指令的执行速率，这得益于流水线(pipelining)的使用。 在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据(single-instruction, multiple-data)，即SIMD并行。 ","date":"2019-12-02","objectID":"/csapp_chapter1/:9:2","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":["读书笔记"],"content":"1.9.3 计算机系统中抽象的重要性 抽象的使用时计算机科学中最为重要的概念之一。 ","date":"2019-12-02","objectID":"/csapp_chapter1/:9:3","tags":["caspp"],"title":"[CSAPP]第一章 计算机系统漫游","uri":"/csapp_chapter1/"},{"categories":null,"content":"hello world! ","date":"2019-12-01","objectID":"/my-first-post/:0:0","tags":null,"title":"My First Post","uri":"/my-first-post/"}]