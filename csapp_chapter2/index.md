# [CSAPP]第二章 信息的表示和处理


## 2.1 信息存储

### 2.1.1 十六进制表示法
### 2.1.2 字数据大小
### 2.1.3 寻址和字节顺序
### 2.1.4 表示字符串
### 2.1.5 表示代码
### 2.1.6 布尔代数简介
### 2.1.7 C语言中的位级运算
### 2.1.8 C语言中的逻辑运算
### 2.1.9 C语言中的移位运算


## 2.2 整数表示

### 2.2.1 整数数据类型
### 2.2.2 无符号数的编码
### 2.2.3 补码编码
### 2.2.4 有符号数和无符号数之间的转换
### 2.2.5 C语言中的有符号数和无符号数
### 2.2.6 扩展一个数字的位表示
### 2.2.7 截断数字
### 2.2.8 关于有符号数与无符号数的建议


## 2.3 整数运算

### 2.3.1 无符号加法
### 2.3.2 补码加法
### 2.3.3 补码的非
### 2.3.4 无符号乘法
### 2.3.5 补码乘法
### 2.3.6 乘以常数
### 2.3.7 除以2的幂
### 2.3.8 关于整数运算的最后思考

## 2.4 浮点数

### 2.4.1 二进制小数
### 2.4.2 IEEE浮点表示

IEEE浮点标准用 $V=(-1)^s \times M \times 2^E$ 的形式来表示一个数：
- **符号(sign)** $s$ 决定这个数是正数还是负数
- **尾数(significand)** $M$ 是一个二进制小数，它的范围是 $1$ 到 $2 - \varepsilon$ 或者是 $0$ 到 $1 - \varepsilon$
- **阶码(exponent)** $E$ 的作用是对浮点数加权，这个权重是2的$E$次幂(可能是负数)

将浮点数的位表示划分为三个字段，分别对这些值进行编码：
- 一个单独的符号位 $s$ 直接编码符号 $s$
- $k$ 位的阶码字段 $exp={e_{k-1}}{···}{e_1}{e_0}$ 编码阶码 $E$
- $n$ 位小数字段 $frag={f_{n-1}}{···}{f_1}{f_0}$ 编码尾数 $M$ ，但是编码出来的值也依赖于阶码字段的值是否等于0


| bits len | s | exp | frag |
|----------|---|-----|------|
| 32 bits  | 1 | 8   | 23   |
| 64 bits  | 1 | 11  | 52   |

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_2_4_2_float_format.png)

给定位表示，根据exp的值，被编码的值可以分成三种不同的情况(最后一种情况有两个变种)

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_2_4_2_float_categories.png)

情况1：规格化的值
当exp的位模式不全为0且不全为1时，这是最普遍的情况。
阶码被解释为以**偏置(biased)**形式表示的有符号整数，即 $E=e-Bias$ ，其中 $e$ 是具有 ${e_{k-1}}{···}{e_1}{e_0}$ 位表示的无符号整数，而 $Bias$ 是一个等于 $2^{k-1} - 1$ (单精度是127，双精度是1023)的偏置值。由此产生的取值范围，对于单精度float是-126~+127，对于双精度double是-1022~+1023。
小数字段frac被解释为描述小数值 $f$ ，其中 $0 \leqslant f < 1$ ，其二进制表示为 $0.{f_{n-1}···{f_1}{f_0}}$ ，也就是二进制小数点在最高有效位的左边。尾数定义为 $M=1+f$ ，这种方式也叫做**隐含的以1开头的(implied leading 1)**表示，因为我们可以把 $M$ 看成一个二进制表达式为 $1.{f_{n-1}···{f_1}{f_0}}$ 的数字。我们可以通过调整 $E$ 来使得尾数 $M$ 保持在 $1 \leqslant M < 2$ 范围之中(假设没有溢出)。既然第一位总是1，那么我们就不需要显示地表示它，因此我们也获得了一个额外的精度位。

情况2：非规格化的数
阶码域全为0。阶码值是 $E=1-Bias$ ，尾数值是 $M=f$
非规格化数有两个用途。
首先是表示0。符号位是0，其他位全是0，值为+0.0；符号位是1，其他位全是0，值为-0.0。
其次，可用于表示那些非常接近0.0的数。它们提供了一种属性，称为**逐渐溢出(gradual underflow)**，其中，可能的数值分布均匀地接近于0.0。

情况3：特殊值
阶码域全为1。
当小数域全为0时，得到的值表示无穷。当 $s=0$ 时是 $+\infty$，当 $s=1$ 时是 $-\infty$。
当小数域为非零时，结果值被称为 $NaN$ ，即"not a number"的缩写。

### 2.4.3 数字示例

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_2_4_3_8bits_float.png)

上图是8位浮点格式的实例。其中4个阶码位，3个小数位。偏置量是 $2^{4-1}-1=7$

可以观察到最大非规格化数 $\frac{7}{512}$ 和最小规格化数 $\frac{8}{512}$ 之间的平滑转变。这种平滑性归功于我们对非规格化数的 $E$ 的定义。

这种表示有一种有趣的属性。加入我们将途中的值的位表达式解释为无符号整数，它们就是按生序排列的，就像它们表示的浮点数一样。这是IEEE特意设计的，可以让浮点数使用整数排序函数来进行排序。当处理负数时，要注意开头的1，并且它们是按降序出现的。

下图展示了一些重要的单精度和双精度的非负浮点数的表示和数字值。

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_2_4_3_nonnegative_float.png)

### 2.4.4 舍入

因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算。因此，对于值 $x$ ，我们一般想用一种系统的方法，能够找到“最接近的”匹配值 $x^{'}$ ，它可以用期望的浮点形式表示出来。这就是**舍入(rouding)**运算的任务。一个关键问题是在两个可能值的中间确定舍入方向。

IEEE浮点格式定义了四种不同的舍入方式。默认的方法是找到最接近的匹配，其他三种可用于计算上下界。

向偶数舍入(round-to-even)，也被称为向最接近的值舍入(round-to-nearest)，是默认的方式，试图找到一个最接近的匹配值。它将数字向上或者向下舍入，使得结果的最低有效位数字是偶数。

向偶数舍入法能够运用到二进制小数上。我们将最低有效位的值0认为是偶数，值1认为是奇数。

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_2_4_4_rouding.png)

### 2.4.5 浮点运算

把浮点值 $x$ 和 $y$ 看成实数，而某个运算 $\bigodot$ 定义在实数上，计算将产生 $x \bigodot y$ ，这是对实际运算的精确结果进行舍入后的结果。

浮点加法不具有结合性。另一方面，浮点加法满足了单调性属性。

### 2.4.6 C语言中的浮点数


## 参考资料
[What Every Computer Scientist Should Know About Floating-Point Arithmetic](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)

