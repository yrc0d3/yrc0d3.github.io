# [CSAPP]第七章 链接


**链接**(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被**加载**(复制)到内存并执行。

执行时机：
- 编译时(compiler time)，即源代码被翻译成机器代码时
- 加载时(load time)，即程序被加载器(loader)加载到内存并执行时
- 运行时(run time)，即有运行程序来执行

现代系统中，链接时由叫做**链接器**(linker)的程序自动执行的。链接使得**分离编译**(seperate compliation)成为可能。

此后的讨论基于linux-64系统下标准的ELF-64目标文件格式。

## 7.1 编译器驱动程序

示例程序：
```
// main.c
int sum(int *a, int n);
int array[2] = {1, 2};
int main() {
    int val = sum(array, 2);
    return val;
}

// sum.c
int sum(int *a, int n) {
    int i, s = 0;
    for (i =0; i < n; i++) {
        s += a[i];
    }
    return s;
}
```

大多数编译系统提供**编译器驱动程序**(compiler driver)，它代表用户在需要时调用语言预处理器、编译器、汇编器、链接器。使用GNU编译系统构造示例程序，可以用命令`gcc -Og -o prog main.c sum.c`

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_1_link.png)

上图概括了驱动程序将示例程序从ASCII码源文件翻译成可执行目标文件时的行为。过程包括：
- 运行C预处理器(C preprocessor, cpp)，将main.c翻译成一个ASCII码的中间文件(intermedia file)main.i
- 运行C编译器(C compiler, cc1)，将main.i翻译成ASCII码汇编语言文件main.s
- 运行汇编器(assembler, as)，将main.s翻译成一个可重定位目标文件(relocatable object file)main.o
- 经历上述相同过程生成sum.o
- 运行链接器程序(linker, ld)，将main.o和sum.o以及一些必要的系统文件组合起来，创建一个可执行目标文件(executable object file)prog
- 在shell中执行`./porg`可运行prog。shell调用操作系统中一个叫做加载器(loader)的函数，它将可执行文件prog中的代码和数据复制到内存，然后将控制转移到这个程序的开头。

```
cpp [other options] main.c /tmp/main.i
cc1 /tmp/main.i -Og [other options] -o /tmp/main.s
as [other options] -o /tmp/main.o /tmp/main.s
ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o
```

## 7.2 静态链接

像Linux LD程序这样的**静态链接器**(static linker)以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件是由各种不同的代码和数据节(section)组成，每一节都是一个连续的字节序列。

为了构造可执行文件，链接器必须完成两个主要任务：
- 符号解析(symbol resolution)。目的是将每个符号引用正好和一个符号定义关联起来。
- 重定位(relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存地址位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

## 7.3 目标文件

目标文件由三种形式：
- 可重定位目标文件：包含二进制代码和数据。其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。
- 可执行目标文件：包含二进制代码和数据。其形式可以被直接复制到内存并执行。
- 共享目标文件：可以在加载或运行时被动态地加载进内存并链接。

编译器和汇编器生成可重定位目标文件(包括共享目标文件)。链接器生成可执行目标文件。

各个系统的目标文件格式都不相同。现代Linux系统使用可执行可链接格式(Executable and Linkable Format, ELF)。

## 7.4 可重定位目标文件

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_4_elf_format.png)

ELF header以一个16字节的序列(描述了系统字长和字节顺序)开始，剩下的部分包含的信息可帮助链接器进行语法分析和解析目标文件。
section header table描述了不同节的位置和大小，每个节都有一个固定大小的条目(entry)。
ELF header和section header table之间是不同的节：
- .text: 已编译程序的机器代码
- .rodata: read-only data，如printf中的格式串和switch语句中的跳转表
- .data: 已初始化的全局和静态C变量
- .bss: 未初始化的全局和静态C变量，以及所有被初始化未0的全局或静态变量。不占实际空间，只是占位符。Block Storage Start，简单记法为Better Save Space。
- .symtab: symbol table，存放程序中定义和引用的函数和全局变量信息。注意，并不包含局部变量
- .rel.text: 一个.text section中的位置列表，链接器组合目标文件时需要修改这些位置
- .rel.data: 被module引用或定义的所有全局变量的重定位信息。
- .debug: debugging symbol table，其条目时程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件
- .line: 原始C源程序中的行号和.text section中机器指令之间的映射
- .strtab: string table，其内容包括.symtab和.debug中的符号表，以及section headers中的section name。

## 7.5 符号和符号表

在链接器的上下文中，有三种不同的符号：
- 由模块m定义并能被其他模块引用的**全局符号**，对应nonstatic C functions and global variables
- 由其他模块定义并被模块m引用的**全局符号**，对应其他模块中的nonstatic C functions and global variables
- 只能被模块m定义和引用的**局部符号**，对应static C functions and global variables、

.symtab中并不包含local nonstatic变量，因为它们在运行时在栈中被管理，链接器对这类符号不感兴趣。

符号表是由汇编器通过使用编译器输出到汇编语言.s文件中的符号构造的。.symtab section中包含ELF符号表，它包含an array of entries。entry的结构如下：
```
typedef struct {
    int   name;      \* String table offset *\
    char  type:4,    \* Function or data (4 bits) *\
          binding:4; \* Local or global (4 bits) *\
    char  reserved;  \* Unused *\
    short section;   \* Section header index*\
    long  value;     \* Section offset or absolute address *\
    long  size;      \* Object size in bytes *\
} Elf64_Symbol;
```

每个符号都被分配到目标文件的某个section，由section字段表示。有三个特殊的伪节(pseudosection)，它们在section header table中没有条目：ABS代表不该被重定位的符号；UNDEF代表未定义的符号，也就是在本module中引用，但在其他地方定义的符号；COMMON表示还未被分配位置的未初始化的数据目标。

COMMON和.bss的区别：
- COMMON: 未初始化的全局变量
- .bss: 未初始化的静态变量，以及初始化为0的全局或静态变量

GNU READELF程序是一个方便查看目标文件内容的工具。下图是示例程序main.o的符号表的最后三个条目：
![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/caspp_7_5_symtab.png)
Ndx=1表示.text section，Ndx=3表示.data section

## 7.6 符号解析

链接器解析符号引用的方法是，将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。每个模块中每个local symbol只能由一个定义，解析较简单。

对global symbol的解析就麻烦了。当编译器遇到一个不是在当前模块中定义的符号(变量或函数)时，会假设该符号是在其他某个模块中定义的，然后生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用的符号的定义，就输出一条错误信息并终止。

对全局符号的符号解析很棘手，还因为多个目标文件可能会定义相同名字的全局符号。在这种情况中，链接器必须要么报错，要么选出一个定义并抛弃其他定义。

### 7.6.1 链接器如何解析多重定义的全局符号

链接器的输入是一组可重定位目标文件。

在编译时，编译器向汇编器输出每个全局符号，要么**强**(strong)要么**弱**(weak)，汇编器再把这个信息隐含地编码再可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。

根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：
- 规则1: 不允许有多个同名的强符号。
- 规则2: 如果有一个强符号和多个弱符号同名，那么选择强符号。
- 规则3: 如果有多个弱符号同名，那么从这些弱符号中任意选择一个。

规则2和规则3会造成一些不易察觉的运行时错误，尤其是如果重复的符号定义还有不同的类型时。

### 7.6.2 与静态库链接

迄今为止，我们都是假设链接器读取一组可重定位目标文件，并把它们链接起来，形成一个输出的可执行文件。实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，成为**静态库**(static library)，它可以用作链接器的输入。当链接器构造一个输出的可执行文件时，它只是复制静态库中被应用程序引用的目标模块。

为什么系统要支持库的概念？

大部分系统都定义了一组广泛的I/O、字符串操作和整数数学函数。如果不使用静态库，那么编译器开发人员要使用什么方方法来向用户提供这些函数呢？
1. 让编译器辨认出对标准函数的调用，并直接生成相应的代码。这种方法将给编译器增加显著的复杂性，而且每次添加、删除或修改一个标准函数时，需要更新编译器版本。
2. 将所有的标准函数都放在一个单独的可重定位目标模块中，应用程序员可以把这个模块链接到他们的可执行文件中。缺点是系统中每个可执行文件都包含一份标准函数集合的完全副本，浪费硬盘和内存。另一个缺点是标准函数的任何变动，都要求库的开发人员重新编译整个源文件，费时费力。
3. 为每个标准函数创建一个独立的可重定位文件，并存放在约定好的目录。缺点是要求应用程序员显式地链接合适的目标模块到它们的可执行文件中，耗时且易出错。

静态库概念被提出来，以解决这些不同方法的缺点。

相关的函数可以被编译为独立的目标模块，然后封装称一个单独的静态库文件。然后，应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数。比如，使用C标准库和数学库中函数的程序可以用如下的命令行来编译和链接：

```
linux> gcc main.c /use/lib/libm.a /usr/lib/libc.a
```

在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字。

在Linux系统中，静态库以一种称为**存档**(archive)的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀.a标识。（备注：.a文件是一组.o文件的集合）

后面的讨论基于图7-6中的代码。

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_6.png)

为了使用这个库，我们编写一个应用，如图7-7。

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_7.png)

图7-8概括了链接器的行为。

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_8.png)

### 7.6.3 链接器如何使用静态库来解析引用

在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。

这种算法会导致一些令人困惑的链接时错误，因为顺序很重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。

关于库的一般准则是将它们放在命令行的结尾。如果库互相独立，那么顺序任意。如果库不是互相独立，那么必须对它们排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义是在对s的引用之后的。

## 7.7 重定位

一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并数据模块，并为每个符号分配运行时地址。

重定位由两步组成：
- 重定位节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的.data节被全部合并成一个节，这个节称为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。
- 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为**重定位条目(relocation entry)**的数据结构。

### 7.7.1 重定位条目

当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个**重定位条目**，高速链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条放在.rel.text中，已初始化数据的重定位条目放在.rel.data中。

```
typedef struct {
    long offset;    /* Offset of the reference to relocate */
    long type:32,   /* Relocation type */
         symbol:32; /* Symbol table index */
    long addend;    /* Constant part of relocation expression */
} Elf64_Rela;
```

ELF定义了32种不同的重定位类型，我们只关心两种最基本的：
- R_X86_64_PC32。重定位一个使用32位PC相对地址的引用。
- R_X86_64_32。重定位一个使用32位绝对地址的引用。

### 7.7.2 重定位符号引用

图7-10是链接器的重定位算法的伪代码。其中，s是secion，r是relocation entry。

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_10.png)

图7-11给出了main.o的反汇编代码。

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_11.png)

#### 1. 重定位PC相对引用

图7-11的第6行，main调用sum。
假定链接器已经确定
```
ADDR(s) = ADDR(.text) = 0x4004d0
ADDR(r.symbol) = ADDR(sum) = 0x4004e8
```

#### 2. 重定位绝对引用

图7-11的第4行种，mov将array的地址复制到%edi中。
假定链接器已经确定
```
ADDR(r.symbol) = ADDR(array) = 0x601018
```

综合起来，图7-12给出了最终可执行目标文件中已重定位的.text节和.data节。在加载的时候，加载器会把这些节中的字节直接复制到内存，不再进行任何修改地执行这些指令。

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_12.png)

## 7.8 可执行目标文件

图7-13概括了一个典型的ELF可执行文件中的各类信息。

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_13.png)

ELF头描述文件的总体格式。它还包括程序的入口点(entry point)，也就是当程序运行时要执行的第一条指令的地址。

因为ELF可执行文件是完全链接的(已被重定位)，所以它不再需要.rel节。.test、.rodata、.data节也都已重定位到它们最终的运行时内存地址。

ELF可执行文件被设计得很容易加载到内存，可执行文件的连续的片(chunk)被映射到连续的内存段。程序头部表(program header table)描述了这种映射关系。

图7-14展示了可执行文件prog的程序头部表。

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_14.png)

从中可以看出，根据可执行目标文件的内容初始化了两个内存段。

第1、2行，代码段，有读/执行权限(rx)，开始于内存地址0x400000，总共占用内存大小0x69字节，并且被初始化位可执行目标文件的头0x69c个字节，其中包括ELF头、程序头部表以及.init、.text和.rodata节。

第3、4节，数据段，有读/写权限(rw)，开始于内存地址0x600df8，总共占用内存大小0x230字节，并且从目标文件中偏移0xdf8处开始的.data节中的0x228个字节初始化。

## 7.9 加载可执行目标文件

通过在shell中执行`./prog`可以运行可执行目标文件prog。

因为它不是内置的shell命令，shell会认为prog是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器(loader)的操作系统代码来运行它。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个奖程序复制到内存并运行的过程叫做加载。

每个Linux程序都有一个运行时内存映像，类似于图7-15。

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_15.png)

在Linux x86-64系统中，代码段重视从地址0x400000处开始，后面是数据段。运行时堆在数据段之后，通过调用malloc库往上增长。堆后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址($2^{48}-1$)开始，向较小内存地址增长。栈上的区域，从地址$2^{48}$开始，是为内核中的代码和数据保留的。

为了简洁，我们把堆、数据和代码段画得彼此相邻，并且把栈顶放在了最大的合法用户地址处。是加上，由于.data段有对齐要求，代码段和数据段之间是有间隙的。同时，在分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间布局随机化(ASLR)。虽然每次程序运行时这些区域的地址都会变，但它们的相对位置是不变的。

## 7.10 动态链接共享库

静态库有一些明显的缺点：
- 需要定期维护和显示地更新。
- 像printf这种函数代码会被复制到每个运行进程的文本段中，浪费内存。

共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接(dynamic linking)，是由一个叫做动态链接器(dynamic linker)的程序来执行的。共享库也称为共享目标(shared object)，在Linux系统中通常用.so后缀来表示。windows中称为DDL。

共享库是以两种不同的方式来“共享”的：
1. 在任何给定的文件系统中，对于一个库只有一个.so文件。所有引用该库的可执行目标文件共享这个.so文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。
2. 在内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。

图7-16概括了图7-7中示例程序的动态链接过程。

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_16.png)

可执行目标文件prog21在运行时可以和libvector.so链接。基本思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。

## 7.11 从应用程序中加载和链接共享库

应用程序可以在它运行时要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接到应用中。

动态链接是一项强大有用的技术。可以用来构建高性能web服务器。其思路是将每个生成动态内容的函数打包在共享库中。当一个来自web浏览器的请求到达时，服务器动态地加载和链接适当的函数，然后直接调用它，而不是使用fork和execve在子进程的上下文中运行函数。函数会一直缓存在服务器的地址空间中，所以只要一个简单的函数调用的开销就可以处理随后的请求了。在运行时无需停止服务器，就可以更新已存在的函数，以及添加新的函数。

Linux系统为动态链接器提供了简单的接口，允许应用程序在运行时加载和链接共享库。

图7-17展示了如何利用这个接口动态链接我们的libvector.so共享库，然后调用它的addvec例程。

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_17.png)

## 7.12 位置无关代码

共享库的一个主要目的是允许多个正在运行的进程共享内存中相同的库代码，因而节约宝贵的内存资源。那么，多个进程是如何共享程序的一个副本的呢？

一种方法是给每个共享库分配一个实现预备的专用的地址空间片，然后要求加载器总是在这个地址记载共享库。这种方法虽简单，但也造成了一些严重的问题。它对地址空间的使用效率不高，即使没有进程使用这个库，地址空间还是会被分配。它也难以管理，我们必须保证没有片会重叠，还要为新库寻找地址空间。

要避免这些问题，现在系统编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需被链接器修改。使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本。(当然，每个进程仍然会有它自己的读/写数据段)

可以加载而无需重定位的代码称为位置无关代码(Position-Independent Code, PIC)。

### 1. PIC数据引用

编译器通过以下事实来生成对全局变量的PIC引用：
无论我们在内存中的何处加载一个目标模块(包括共享目标模块)，数据段和代码段之间的距离总是保持不变。因此，代码段中任何指令和数据段中的任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的。

想要生成对全局变量PIC引用的编译器利用了这个事实，它在数据段开始的地方创建了一个表，叫做全局偏移量表(Global Offset Table, GOT)。编译器为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址。

### 2. PIC函数调用

GNU编译系统使用延迟绑定(lazy binding)，将过程地址的绑定推迟到第一次调用该过程时。

延迟绑定时通过GOT和PLT(过程链接表，Procedure Linkable Table)这两个数据结构来实现的。

## 7.13 库打桩机制

Linux链接器支持一个很强大的技术，称为库打桩(library interpositioning)。它允许你截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，你可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入和输出，或者把它替换成一个完全不同的实现。

基本思想：给定一个需要打桩的目标函数，创建一个包装函数，它的原型与目标函数完全一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。保证函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。

打桩可以发生在编译时、链接时或者当程序被加载和执行的运行时。

### 7.13.1 编译时打桩

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_20.png)

图7-20展示了如何使用C预处理器在编译时打桩。

```
> gcc -DCOMPILETIME -c mymalloc.c
> gcc -I. -o intc int.c mymalloc.o
```

由于有`-I.`参数，所以会进行打桩，它告诉C预处理器在搜索通常的系统目录之前，先在当前目录中查找malloc.h。

### 7.13.2 链接时打桩

Linux静态链接器支持用`--wrap f`标志进行链接时打桩。这个标志告诉链接器，把对符号`f`的引用解析成`__wrap_f`(前缀是两个下划线)，还要把对符号`__real_f`(前缀是两个下划线)的引用解析为`f`。

图7-21给出我们示例程序的包装函数。

```
> gcc -DLINKTIME -c mymalloc.c
> gcc -c int.c
> gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o
```

![](https://raw.githubusercontent.com/yrc0d3/imagehosting/master/img/csapp_7_21.png)

### 7.13.3 运行时打桩

编译时打桩需要能够访问程序的源代码，链接时打桩需要能够访问程序的可重定位目标文件。运行时打桩基于动态链接器的LD_PRELOAD环境变量。

如果LD_PRELOAD环境变量被设置为一个共享库路径名的列表，那么当你加载和执行一个程序，需要解析未定义的引用时，动态链接器(LD-LINUX.so)会先搜索LD_PRELOAD库，然后才搜索任何其他的库。有了这个机制，当你加载和执行任何可执行文件时，可以对任何共享库中的任何函数打桩，包括libc.so。

## 7.14 处理目标文件的工具

GNU binutils包可以运行在每个Linux平台上：
- AR：创建静态库，插入、删除、列出、提取成员。
- STRINGS：列出一个目标文件中所有可打印的字符串。
- STRIP：从目标文件中删除符号表信息。
- NM：列出一个目标文件的符号表中定义的符号。
- READELF：显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能。
- OBJDUMP：所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用时反汇编.text节中的二进制指令。

Linux中的LDD：列出一个可执行文件在运行时所需要的共享库。


